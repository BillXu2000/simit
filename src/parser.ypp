%code top{
  #include <stdlib.h>
  #include <cassert>
  #include <iostream>
  #include <algorithm>

  #include "logger.h"
  #include "frontend.h"
  #include "util.h"
  #include "errors.h"
  using namespace std;
  using namespace simit;

  #define REPORT_ERROR(msg, loc)                     \
    do {                                             \
      yyerror(&loc, ctx, std::string(msg).c_str());  \
      YYERROR;                                       \
    } while (0)
}

%code requires {
  #include <vector>

  #include "ir.h"
  #include "types.h"

  namespace simit {
  struct ParseParams {
    ParseParams(simit::SymbolTable &symtable,
                std::list<simit::Error> &errors, std::list<simit::Test> &tests)
               : symtable(symtable), errors(errors), tests(tests) {}

    simit::SymbolTable &symtable;
    std::list<std::shared_ptr<simit::IRNode>> programNodes;
    std::list<simit::Error> &errors;
    std::list<simit::Test> &tests;
  };
  }
}

%require "3.0"
%define parse.error verbose
%define parse.lac full
%locations
%pure-parser


%parse-param{simit::ParseParams *ctx};

%union {
  // Primitive literals
  int          num;
  double      fnum;
  const char *string;
}
%destructor {} <num> <fnum> <ComponentType>
%destructor { free((void*)($$)); } <string>
%destructor { delete $$; } <*>

%code {
  #include "scanner.h"
  void yyerror(YYLTYPE *loc, ParseParams *ctx, const char *errorStr) {
    ctx->errors.push_back(Error(loc->first_line, loc->first_column,
                                loc->last_line, loc->last_column,
                                errorStr));
  }
}

%token UNKNOWN

// Literals
%right    "="
%nonassoc "\\"               // solve
%left     "==" "!="
%left     "<" ">" "<=" ">="
%left     "-" "+"
%left     "*" "/"
%left     NEG                // negation
%right    "^"                // exponentiation
%right    "'"                // transpose

%token <num>    INT_LITERAL    "int literal"
%token <fnum>   FLOAT_LITERAL  "float literal"
%token <string> STRING_LITERAL "string literal"
%token <string> IDENT          "identifier"

// Keywords
%token INT       "int"
%token FLOAT     "float"
%token STRUCT    "struct"
%token CONST     "const"
%token EXTERN    "extern"
%token PROC      "proc"
%token FUNC      "func"
%token TENSOR    "Tensor"
%token MAP       "map"
%token TO        "to"
%token WITH      "with"
%token REDUCE    "reduce"
%token WHILE     "while"
%token IF        "if"
%token ELIF      "elif"
%token ELSE      "else"
%token BLOCKEND  "end"
%token RETURN    "return"
%token TEST      "test"

%token RARROW    "->"
%token LP        "("
%token RP        ")"
%token LB        "["
%token RB        "]"
%token LC        "{"
%token RC        "}"
%token LA        "<"
%token RA        ">"
%token COMMA     ","
%token PERIOD    "."
%token COL       ":"
%token SEMICOL   ";"

%token ASSIGN    "="
%token PLUS      "+"
%token MINUS     "-"
%token STAR      "*"
%token SLASH     "/"
%token EXP       "^"
%token TRANSPOSE "'"
%token BACKSLASH "\\"

%token EQ        "=="
%token NE        "!="
%token LE        "<="
%token GE        ">="

// End of file
%token END 0 "end of file"


%start program
%%
program
  : /* empty */
  | program program_element {
    if ($program_element != NULL) {  // TODO: Remove this check
      ctx->programNodes.insert(ctx->programNodes.end(), $2->begin(), $2->end());
      delete $2;
    }
  }

%union {
  std::list<std::shared_ptr<simit::IRNode>> *IRNodes;
};

%type<IRNodes> program_element;
// TODO: Move all of these actions to the program rule
program_element
  : struct {
    $$ = NULL;
  }
  | procedure {
    $$ = NULL;
  }
  | function {
    $$ = NULL;
  }
  | extern {
    $$ = NULL;
  }
  | stmt
  | test

// Externs
extern
  : "extern" IDENT type "{" "}" ";" {
    free((void*)$IDENT);
    delete $type;
  }
  | "extern" IDENT type "[" endpoints "]" "{" "}" ";" {
    free((void*)$IDENT);
    delete $type;
  }

endpoints
  : IDENT {
    free((void*)$IDENT);
  }
  | endpoints "," IDENT {
    free((void*)$IDENT);
  }


// Structs
struct
  : "struct" IDENT struct_decl_block {
    free((void*)$IDENT);
  }

struct_decl_block
  : /* empty */
  | struct_decl_list BLOCKEND

struct_decl_list
  : /* empty */
  | field_decl struct_decl_list

field_decl
  : var_decl  ";"


// Procedures and functions
procedure
  : PROC IDENT stmt_block BLOCKEND {
    free((void*)$IDENT);
  }

function
  : function_header stmt_block BLOCKEND {
    ctx->symtable.unscope();
  }

function_header
  : FUNC IDENT "(" params ")" results {
    string ident($IDENT);
    free((void*)$IDENT);

    ctx->symtable.scope();
    for (auto param : *$params) {
//      ctx->symtable.addNode(param);
    }

    for (auto result : *$results) {
//      ctx->symtable.addNode(result);
    }
  }

%union {
  std::shared_ptr<simit::Formal>            *Formal;
  std::list<std::shared_ptr<simit::Formal>> *Formals;
};

%type <Formals> params;
params
 : /* empty */ {
    $$ = new list<shared_ptr<Formal>>();
 }
 | formal_list

%type <Formals> results;
results
  : /* empty */ {
    $$ = new list<shared_ptr<Formal>>();
  }
  | RARROW "(" formal_list ")" {
    $$ = $formal_list;
  }

%type <Formal> formal_decl;
formal_decl
  : IDENT ":" type {
    string ident($IDENT);
    free((void*)$IDENT);
    auto formal = new Formal(ident, $type);
    $$ = new shared_ptr<Formal>(formal);
  }

%type <Formals> formal_list;
formal_list
  : formal_decl {
    $$ = new list<shared_ptr<Formal>>();
    $$->push_back(*$formal_decl);
    delete $formal_decl;
  }
  | formal_list "," formal_decl {
    $$->push_back(*$formal_decl);
    delete $formal_decl;
  }

// Statements
stmt_block
  : /* empty */
  | stmt_block stmt

%type<IRNodes> stmt;
%type<IRNodes> const_stmt;
%type<IRNodes> if_stmt;
%type<IRNodes> return_stmt;
%type<IRNodes> assign_stmt;
%type<IRNodes> expr_stmt;

stmt
  : const_stmt
  | if_stmt
  | return_stmt
  | assign_stmt
  | expr_stmt

const_stmt
  : "const" IDENT ":" tensor_type "=" tensor_literal ";" {
    auto tensorType = unique_ptr<TensorType>($tensor_type);

    auto tensorLiteral = shared_ptr<LiteralTensor>(*$tensor_literal);
    delete $tensor_literal;

    tensorLiteral->setName($IDENT);
    free((void*)$IDENT);

    // If $type is a 1xn matrix and $tensor_literal is a vector then we cast
    // $tensor_literal to a 1xn matrix.
    if (tensorType->getOrder() == 2 && tensorLiteral->getOrder() == 1) {
      tensorLiteral->cast(tensorType.release());
    }

    // Typecheck: value and literal types must be equivalent.
    //            Note that the use of $tensor_type is deliberate as tensorType
    //            can have been released.
    if (*$tensor_type != *(tensorLiteral->getType())) {
      REPORT_ERROR("value and literal types do not match", @5);
    }

    ctx->symtable.addNode(tensorLiteral);

    $$ = new list<shared_ptr<IRNode>>();
    $$->push_back(tensorLiteral);
  }
  | "const" IDENT ":" element_type "=" element_literal ";" {
    free((void*)$IDENT);
    delete $element_type;
  }

if_stmt
  : "if" expr stmt_block else_clauses BLOCKEND

else_clauses
  : /* empty */
  | elif_clauses "else" stmt_block

elif_clauses
  : /* empty */
  | elif_clauses "elif" expr stmt_block

return_stmt
  : "return" ";"

assign_stmt
  : lhs_expr_list "=" expr_list ";" {
    auto lhsList = unique_ptr<list<shared_ptr<Store>>>($lhs_expr_list);
    auto rhsList = unique_ptr<list<shared_ptr<Tensor>>>($expr_list);

    if (lhsList->size() > rhsList->size()) {
      // REPORT_ERROR("too few expressions assigned to too many variables", @2);
      break;
    }
    else if (lhsList->size() < rhsList->size()) {
      REPORT_ERROR("too mant expressions assigned to too few variables", @2);
    }

    $$ = new list<shared_ptr<IRNode>>();

    auto lhsIter = lhsList->begin();
    auto rhsIter = rhsList->begin();
    for (; lhsIter != lhsList->end(); ++lhsIter, ++rhsIter) {
      auto lhs = *lhsIter;
      auto rhs = *rhsIter;

      // TODO: Remove this
      if (rhs == NULL) continue;

      if (dynamic_pointer_cast<VariableStore>(lhs) != NULL) {
        rhs->setName(lhs->getName());
        ctx->symtable.addNode(rhs);
        $$->push_back(rhs);
      }
      else {
        // TODO: Implement
        assert(false);
      }
    }
  }

expr_stmt
  : ";"
  | expr ";"


// Expressions
%union {
  std::shared_ptr<simit::Tensor>            *Tensor;
  std::list<std::shared_ptr<simit::Tensor>> *TensorList;
  std::shared_ptr<simit::Store>             *Store;
  std::list<std::shared_ptr<simit::Store>>  *StoreList;
};

%type<Tensor> expr;
expr
  : IDENT {
    string ident($IDENT);
    free((void*)$IDENT);
    std::shared_ptr<IRNode> &node = ctx->symtable[ident];
    if (node == NULL) {
      // TODO: reintroduce error
      // REPORT_ERROR(ident + " is not defined in scope", @1);
      $$ = NULL;
      break;
    }

    shared_ptr<Tensor> tensor = dynamic_pointer_cast<Tensor>(node);
    if (tensor == NULL) {
      REPORT_ERROR(ident + " is not a tensor", @1);
    }

    $$ = new shared_ptr<Tensor>(tensor);
  }
  | FLOAT_LITERAL {
    $$ = NULL;
  }
  | INT_LITERAL {
    $$ = NULL;
  }
  | STRING_LITERAL {
    $$ = NULL;
  }
  | expr "\\" expr {
    $$ = NULL;
  }
  | expr "+" expr {
    $$ = NULL;
  }
  | expr "-" expr {
    $$ = NULL;
  }
  | expr "*" expr {
    $$ = NULL;
  }
  | expr "/" expr {
    $$ = NULL;
  }
  | "-" expr %prec NEG {
    if ($2 == NULL) {
      $$ = NULL;
      break; // TODO: Remove check
    }

    auto expr = shared_ptr<Tensor>(*$2);
    delete $2;

    auto indexVars = makeFreeIndexVariables(expr->getOrder());

    std::list<Merge::IndexedTensor> operands;
    operands.push_front(Merge::IndexedTensor(expr, indexVars));

    auto merge = Merge::make(Merge::NEG, indexVars, operands);
    assert(merge != NULL);
    $$ = new shared_ptr<Tensor>(merge);
  }
  | expr "'" {
    $$ = NULL;
  }
  | expr "^" expr {
    $$ = NULL;
  }
  | expr "==" expr {
    $$ = NULL;
  }
  | expr "!=" expr {
    $$ = NULL;
  }
  | expr "<"  expr {
    $$ = NULL;
  }
  | expr ">"  expr {
    $$ = NULL;
  }
  | expr "<=" expr {
    $$ = NULL;
  }
  | expr ">=" expr {
    $$ = NULL;
  }
  | "(" expr ")" {
    $$ = NULL;
  }
  | expr ":" expr {
    $$ = NULL;
  }
  | call_expr {
    $$ = NULL;
  }
  | expr "." expr {
    $$ = NULL;
  }
  | index_expr {
    $$ = NULL;
  }
  | map_expr {
    $$ = NULL;
  }

call_expr
  : expr "(" ")"
  | expr "(" expr_list ")"

%type <TensorList> expr_list;
expr_list
  : expr {
    $$ = new list<shared_ptr<Tensor>>();
    if ($expr == NULL) break;  // TODO: Remove check
    $$->push_back(*$expr);
    delete $expr;
  }
  | expr_list "," expr {
    $$ = $1;
    if ($expr == NULL) break;  // TODO: Remove check
    $$->push_back(*$expr);
    delete $expr;
  }

// Map expressions
map_expr
  : "map" IDENT[target] "to" IDENT[neighbor] with reduce {
    free((void*)$target);
    free((void*)$neighbor);
  }

with
  : /* empty */
  | "with" IDENT {
    free((void*)$IDENT);
  }

reduce
  : /* empty */
  | "reduce" reduction_op


// Index expressions
index_expr
  : reduction_indices expr

reduction_indices
  : /* empty */
  | reduction_indices reduction_index

reduction_index
  : reduction_op IDENT {
    free((void*)$IDENT);
  }
  | reduction_op "{" IDENT "}" {
    free((void*)$IDENT);
  }
  | IDENT[rfunc] "{" IDENT[rval] "}" {
    free((void*)$rfunc);
    free((void*)$rval);
  }

reduction_op
  : "+"
  | "*"


// Lhs expressions
%type<Store> lhs_expr;
lhs_expr
  : IDENT {
    string ident($IDENT);
    free((void*)$IDENT);
    // TODO: Stores probably do not need to be Tensor classes, but could be
    // some parser-internal class...
    auto variableStore = new VariableStore(ident, NULL);
    $$ = new std::shared_ptr<Store>(variableStore);
  }
  | IDENT "(" expr_list ")" {
    $$ = NULL;
  }
  | IDENT "." IDENT {
    $$ = NULL;
  }

%type<StoreList> lhs_expr_list;
lhs_expr_list
  : lhs_expr {
    $$ = new list<shared_ptr<Store>>();
    if ($lhs_expr == NULL) break;  // TODO: Remove check
    $$->push_back(*$lhs_expr);
    delete $lhs_expr;

  }
  | lhs_expr_list "," lhs_expr {
    $$ = $1;
    if ($lhs_expr == NULL) break;  // TODO: Remove check
    $$->push_back(*$lhs_expr);
    delete $lhs_expr;
  }

// Variables
var_decl
  : IDENT ":" type {
    delete $type;
    free((void*)$IDENT);
  }


// Types
%union {
  simit::Type                      *Type;
  simit::TensorType                *TensorType;
  simit::TensorType::ComponentType  ComponentType;
  std::vector<simit::Shape*>       *Shapes;
  simit::Shape                     *Shape;
  std::vector<simit::Dimension*>   *Dimensions;
  simit::Dimension                 *Dimension;
};

%type <TensorType>     type;
%type <TensorType>     tensor_type;
%type <Shapes>         shapes;
%type <Shape>          shape;
%type <Dimensions>     dimensions;
%type <Dimension>      dimension;
%type <ComponentType>  component_type;
%type <TensorType>     element_type;

type
  : element_type {
    $$ = $element_type;
  }
  | tensor_type {
    $$ = $tensor_type;
  }

element_type
  : IDENT {
    $$ = new ScalarType(TensorType::ELEMENT);
    free((void*)$IDENT);
  }

tensor_type
  : component_type {
    $$ = new ScalarType($component_type);
  }
  | TENSOR shapes "(" component_type ")" {
    auto shapes = unique_ptr<vector<Shape*>>($shapes);

    $$ = new ScalarType($component_type);
    typedef vector<Shape*>::reverse_iterator shapes_rit_t;
    for (shapes_rit_t rit = $shapes->rbegin(); rit != $shapes->rend(); ++rit) {
      $$ = new NDTensorType(*rit, $$);
    }
  }

shapes
  : /* empty */ {
    $$ = new vector<Shape*>();
  }
  | shapes shape {
    $$ = $1;
    $$->push_back($shape);
  }

shape
  : "[" dimensions "]" {
    $$ = new Shape(*$dimensions);
    delete $dimensions;
  }

dimensions
  : dimension {
    $$ = new vector<Dimension*>();
    $$->push_back($dimension);
  }
  | dimensions "," dimension {
    $$ = $1;
    $$->push_back($dimension);
  }

dimension
  : INT_LITERAL {
    $$ = new Dimension($INT_LITERAL);
  }
  | IDENT {
    free((void*)$IDENT);
    $$ = new Dimension(123456789);  // TODO: This needs to be a set dimension
  }
  | "*" {
    $$ = new Dimension();
  }

component_type
  : INT {
    $$ = ScalarType::INT;
  }
  | FLOAT {
    $$ = ScalarType::FLOAT;
  }


// Literals
%code requires {
  namespace {
    template <typename T>
    class TensorValues {
     public:
      TensorValues() : dimSizes(1) {};

      void addValue(const T &val) {
        values.push_back(val);
        dimSizes[dimSizes.size()-1]++;
      }
      void addDimension() { dimSizes.push_back(1); }

      bool dimensionsMatch(const TensorValues<T> &other, std::string *errors) {
        assert(errors != NULL);
        std::string mismatchError = "missmatched dimension sizes";
        if (dimSizes.size()-1 != other.dimSizes.size()) {
          *errors = mismatchError;
          return false;
        }

        for (unsigned int i=0; i<dimSizes.size()-1; ++i) {
          if (dimSizes[i] != other.dimSizes[i]) {
            *errors = mismatchError;
            return false;
          }
        }
        return true;
      }

      void merge(const TensorValues<T> &other) {
        values.insert(values.end(), other.values.begin(), other.values.end());
        dimSizes[dimSizes.size()-1]++;
      }

      std::vector<unsigned int> dimSizes;
      std::vector<T>            values;
    };
  }
};

%union {
  std::shared_ptr<simit::LiteralTensor>      *LiteralTensor;
  std::shared_ptr<simit::DenseLiteralTensor> *DenseLiteralTensor;
  TensorValues<double>                       *TensorDoubleValues;
  TensorValues<int>                          *TensorIntValues;
};

%type              <Tensor> literal;
%type      <LiteralTensor> tensor_literal;
%type <DenseLiteralTensor> dense_tensor_literal;
%type <DenseLiteralTensor> scalar_literal;

%type <TensorDoubleValues> float_dense_tensor_literal;
%type <TensorDoubleValues> float_dense_ndtensor_literal;
%type <TensorDoubleValues> float_dense_matrix_literal;
%type <TensorDoubleValues> float_dense_vector_literal;

%type <TensorIntValues> int_dense_tensor_literal;
%type <TensorIntValues> int_dense_ndtensor_literal;
%type <TensorIntValues> int_dense_matrix_literal;
%type <TensorIntValues> int_dense_vector_literal;

literal
  : element_literal
  | tensor_literal

element_literal
  :

tensor_literal
  : dense_tensor_literal
  | scalar_literal

%code {
  Shape *dimSizesToShape(const vector<unsigned int> &dimSizes) {
    auto dims = std::vector<Dimension*>();
    for (auto rit=dimSizes.rbegin(); rit!=dimSizes.rend(); ++rit) {
      dims.push_back(new Dimension(*rit));
    }
    return new Shape(dims);
  }
};

dense_tensor_literal
  : "[" float_dense_tensor_literal "]" {
    auto values = unique_ptr<TensorValues<double>>($2);
    Shape *shape = dimSizesToShape(values->dimSizes);
    auto type = new NDTensorType(shape, new ScalarType(ScalarType::FLOAT));
    auto literal = new DenseLiteralTensor(type, values->values.data());
    $$ = new shared_ptr<DenseLiteralTensor>(literal);
  }
  | "[" int_dense_tensor_literal "]" {
    auto values = unique_ptr<TensorValues<int>>($2);
    Shape *shape = dimSizesToShape(values->dimSizes);
    auto type = new NDTensorType(shape, new ScalarType(ScalarType::INT));
    auto literal = new DenseLiteralTensor(type, values->values.data());
    $$ = new shared_ptr<DenseLiteralTensor>(literal);
  }

float_dense_tensor_literal
  : float_dense_matrix_literal {
    // If the matrix has only one column then we discard that dimension and
    // treat it as a vector.
    if ($1->dimSizes[$1->dimSizes.size()-1] == 1) {
      $1->dimSizes.pop_back();
    }
  }
  | float_dense_ndtensor_literal

float_dense_ndtensor_literal
  : "[" float_dense_matrix_literal "]" {
    $$ = $2;
    $$->addDimension();
  }
  | float_dense_ndtensor_literal "," "[" float_dense_matrix_literal "]" {
    auto  left = unique_ptr<TensorValues<double>>($1);
    auto right = unique_ptr<TensorValues<double>>($4);

    string errorStr;
    if(!left->dimensionsMatch(*right, &errorStr)) {
      REPORT_ERROR(errorStr, @2);
    }
    left->merge(*right);
    $$ = left.release();
  }

float_dense_matrix_literal
  : float_dense_vector_literal {
    $$ = $1;
    $$->addDimension();
  }
  | float_dense_matrix_literal ";" float_dense_vector_literal {
    auto  left = unique_ptr<TensorValues<double>>($1);
    auto right = unique_ptr<TensorValues<double>>($3);

    string errorStr;
    if(!left->dimensionsMatch(*right, &errorStr)) {
      REPORT_ERROR(errorStr, @2);
    }

    left->merge(*right);
    $$ = left.release();
  }

float_dense_vector_literal
  : FLOAT_LITERAL {
    $$ = new TensorValues<double>();
    $$->addValue($1);
  }
  | float_dense_vector_literal "," FLOAT_LITERAL {
    $$ = $1;
    $$->addValue($3);
  }

int_dense_tensor_literal
  : int_dense_matrix_literal {
    // If the matrix has only one column then we discard that dimension and
    // treat it as a vector.
    if ($1->dimSizes[$1->dimSizes.size()-1] == 1) {
      $1->dimSizes.pop_back();
    }
  }
  | int_dense_ndtensor_literal

int_dense_ndtensor_literal
  : "[" int_dense_matrix_literal "]" {
    $$ = $2;
    $$->addDimension();
  }
  | int_dense_ndtensor_literal "," "[" int_dense_matrix_literal "]" {
    auto  left = unique_ptr<TensorValues<int>>($1);
    auto right = unique_ptr<TensorValues<int>>($4);

    string errorStr;
    if(!left->dimensionsMatch(*right, &errorStr)) {
      REPORT_ERROR(errorStr, @2);
    }
    left->merge(*right);
    $$ = left.release();
  }

int_dense_matrix_literal
  : int_dense_vector_literal {
    $$ = $1;
    $$->addDimension();
  }
  | int_dense_matrix_literal ";" int_dense_vector_literal {
    auto  left = unique_ptr<TensorValues<int>>($1);
    auto right = unique_ptr<TensorValues<int>>($3);

    string errorStr;
    if(!left->dimensionsMatch(*right, &errorStr)) {
      REPORT_ERROR(errorStr, @2);
    }

    left->merge(*right);
    $$ = left.release();
  }

int_dense_vector_literal
  : INT_LITERAL {
    $$ = new TensorValues<int>();
    $$->addValue($1);
  }
  | int_dense_vector_literal "," INT_LITERAL {
    $$ = $1;
    $$->addValue($3);
  }

scalar_literal
  : INT_LITERAL {
    auto scalarType = new ScalarType(ScalarType::INT);
    auto literal = new DenseLiteralTensor(scalarType, &$1);
    $$ = new shared_ptr<DenseLiteralTensor>(literal);
  }
  | FLOAT_LITERAL {
    auto scalarType = new ScalarType(ScalarType::FLOAT);
    auto literal = new DenseLiteralTensor(scalarType, &$1);
    $$ = new shared_ptr<DenseLiteralTensor>(literal);
  }

// Tests
%type<IRNodes> test;
test
  : TEST test_stmt_block {
    $$ = new list<shared_ptr<IRNode>>();
    $$->push_back(shared_ptr<IRNode>(new simit::Test("MyTest")));
  }

test_stmt_block
  : /* empty */
  | test_stmt_block test_stmt

test_stmt
  : stmt
  | expr "->" literal ";" {
    auto expr = shared_ptr<Tensor>(*$expr);
    auto literal = shared_ptr<Tensor>(*$literal);
    delete $expr;
    delete $literal;
  }
%%
