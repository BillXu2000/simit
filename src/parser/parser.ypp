%require "3.0"
%language "C++"

%defines
%define api.namespace { simit::internal }
%define parser_class_name { Parser }
%define parse.error verbose
%locations

%code requires {
  namespace simit {
  namespace internal {
    class Scanner;
    class ProgramContext;
  }}

  #include <vector>

  #include "util.h"
  #include "ir.h"
  #include "errors.h"
  #include "types.h"
}

%parse-param { Scanner *scanner };
%parse-param { ProgramContext *ctx };
%parse-param { std::vector<Error> *errors };

%code {
  #include <stdlib.h>
  #include <cassert>
  #include <iostream>
  #include <map>
  #include <set>
  #include <algorithm>

  #include "program_context.h"
  #include "scanner.h"
  #include "ir_codegen.h"
  using namespace std;
  using namespace simit::internal;
  using namespace simit::ir;

  std::string typeString(const Type &type, ProgramContext *ctx) {
    std::stringstream ss;
    ss << type;
    std::string str = ss.str();
    if (ctx->isColumnVector(type)) {
      str += "'";
    }
    return str;
  }

  #define REPORT_ERROR(msg, loc)  \
    do {                          \
      error((loc), (msg));        \
      YYERROR;                    \
    } while (0)

  #define REPORT_TYPE_MISSMATCH(t1, t2, loc)           \
    do {                                               \
      std::stringstream errorStr;                      \
      errorStr << "type missmatch ("                   \
               << typeString(t1, ctx) << " and "       \
               << typeString(t2, ctx) << ")";          \
      REPORT_ERROR(errorStr.str(), loc);               \
    } while (0)

  #define REPORT_INDEX_VARIABLE_MISSMATCH(numIndexVars, order, loc) \
    do {                                                            \
      REPORT_ERROR("wrong number of index variables (" +            \
                    to_string(numIndexVars) +                       \
                    " index variables, but tensor order is " +      \
                    to_string(order), loc);                         \
      } while (0)

  void Parser::error(const Parser::location_type &loc, const std::string &msg) {
    errors->push_back(Error(loc.begin.line, loc.begin.column,
                            loc.end.line, loc.end.column, msg));
  }

  #undef yylex
  #define yylex scanner->lex

  inline std::string convertAndFree(const char *str) {
    std::string result = std::string(str);
    free((void*)str);
    return result;
  }

  template <typename T>
  inline T convertAndDelete(T *obj) {
    auto result = T(*obj);
    delete obj;
    return result;
  }

  bool compare(const Type &l, const Type &r, ProgramContext *ctx) {
    if (l.getKind() != r.getKind()) {
      return false;
    }

    if (l.isTensor()) {
      if (ctx->isColumnVector(l) != ctx->isColumnVector(r)) {
        return false;
      }
    }

    if (l != r) {
      return false;
    }
    return true;
  }

  #define CHECK_IS_TENSOR(expr, loc)                    \
    do {                                                \
      assert(expr->getType());                          \
      if (!expr->getType()->isTensor()) {               \
        std::stringstream errorStr;                     \
        errorStr << "expected tensor";                  \
        REPORT_ERROR(errorStr.str(), loc);              \
      }                                                 \
    } while (0)

  #define CHECK_TYPE_EQUALITY(t1, t2, loc)              \
    do {                                                \
      if (!compare(t1, t2, ctx)) {                      \
        REPORT_TYPE_MISSMATCH(t1, t2, loc);             \
      }                                                 \
    } while (0)


  #define BINARY_ELWISE_TYPE_CHECK(lt, rt, loc)         \
    do {                                                \
      TensorType *ltt = tensorTypePtr(lt);              \
      TensorType *rtt = tensorTypePtr(rt);              \
      if (ltt->getOrder() > 0 && rtt->getOrder() > 0) { \
        CHECK_TYPE_EQUALITY(*ltt, *rtt, loc);           \
      }                                                 \
    }                                                   \
    while (0)
}

%union {
  // Primitive literals
  int         num;
  double      fnum;
  const char *string;
}
%destructor {} <num> <fnum>
%destructor { free((void*)($$)); } <string>
%destructor { delete $$; } <*>


// Tokens
%token UNKNOWN

// Literals
%right    "="
%nonassoc "\\"               // solve
%left     "==" "!="
%left     "<" ">" "<=" ">="
%left     "-" "+"
%left     "*" "/"
%left     NEG                // negation
%right    "^"                // exponentiation
%right    "'"                // transpose

%token <num>    INT_LITERAL    "int literal"
%token <fnum>   FLOAT_LITERAL  "float literal"
%token <string> STRING_LITERAL "string literal"
%token <string> IDENT          "identifier"

// Keywords
%token INT       "int"
%token FLOAT     "float"
%token TENSOR    "tensor"
%token ELEMENT   "element"
%token SET       "set"
%token CONST     "const"
%token EXTERN    "extern"
%token PROC      "proc"
%token FUNC      "func"
%token MAP       "map"
%token TO        "to"
%token WITH      "with"
%token REDUCE    "reduce"
%token WHILE     "while"
%token IF        "if"
%token ELIF      "elif"
%token ELSE      "else"
%token BLOCKEND  "end"
%token RETURN    "return"
%token TEST      "%!"

%token RARROW    "->"
%token LP        "("
%token RP        ")"
%token LB        "["
%token RB        "]"
%token LC        "{"
%token RC        "}"
%token LA        "<"
%token RA        ">"
%token COMMA     ","
%token PERIOD    "."
%token COL       ":"
%token SEMICOL   ";"

%token ASSIGN    "="
%token PLUS      "+"
%token MINUS     "-"
%token STAR      "*"
%token SLASH     "/"
%token DOTSTAR   ".*"
%token DOTSLASH  "./"
%token EXP       "^"
%token TRANSPOSE "'"
%token BACKSLASH "\\"

%token EQ        "=="
%token NE        "!="
%token LE        "<="
%token GE        ">="

// End of file
%token END 0     "end of file"

%start program
%%

%union {
  std::shared_ptr<ir::IRNode>              *IRNode;
  std::vector<std::shared_ptr<ir::IRNode>> *IRNodes;
};

program
  : /* empty */
  | program program_element

%type<IRNode> program_element;
program_element
  : element_type_decl
  | procedure {
    std::unique_ptr<Function> function($procedure);
    std::string name = function->getName();
    if (ctx->containsFunction(name)) {
      REPORT_ERROR("procedure redefinition (" + name + ")", @procedure);
    }
    ctx->addFunction(function.release());
  }
  | function {
    std::unique_ptr<Function> function($function);
    std::string name = function->getName();
    if (ctx->containsFunction(name)) {
      REPORT_ERROR("function redefinition (" + name + ")", @function);
    }
    ctx->addFunction(function.release());
  }
  | extern {
    $$ = NULL;
  }
  | stmt {
    $$ = NULL;
    delete $stmt;
  }
  | test {
    ctx->addTest($test);
  }

// Externs
// TODO: Remove externs
extern
  : "extern" IDENT ":" type ";" {
    std::string ident = convertAndFree($IDENT);
    delete $type;
  }

endpoints
  : IDENT {
    std::string ident = convertAndFree($IDENT);
  }
  | endpoints "," IDENT {
    std::string ident = convertAndFree($IDENT);
  }


// Element Definitions
%union {
  ir::ElementType::FieldsMapType                         *fields;
  std::pair<std::string,std::shared_ptr<ir::TensorType>> *field;
};

%type <elementType> element_type_decl;
element_type_decl
  : "element" IDENT field_decl_list "end" {
    std::string name = convertAndFree($IDENT);
    std::unique_ptr<ir::ElementType::FieldsMapType> fields($field_decl_list);

    if (ctx->containsElementType(name)) {
      REPORT_ERROR("struct redefinition (" + name + ")", @element_type_decl);
    }

    ElementType *elementType = new ElementType(name, *fields);
    ctx->addElementType(std::shared_ptr<ElementType>(elementType));
  }

%type <fields> field_decl_list;
field_decl_list
  : /* empty */ {
    $$ = new ElementType::FieldsMapType();
  }
  | field_decl_list field_decl {
    $$ = $1;
    $$->insert(*$field_decl);
    delete $field_decl;
  }

%type <field> field_decl;
field_decl
  : IDENT ":" tensor_type  ";" {
    std::string name = convertAndFree($IDENT);
    std::shared_ptr<TensorType> tensorType = convertAndDelete($tensor_type);
    $$ = new pair<string,shared_ptr<ir::TensorType>>(name, tensorType);
  }


// Procedures and functions
%union {
  ir::Function *function;
};

%type <function> procedure;
procedure
  : "proc" IDENT {ctx->scope();} stmt_block {ctx->unscope();} BLOCKEND {
    std::string ident = convertAndFree($IDENT);
    auto statements = unique_ptr<vector<shared_ptr<IRNode>>>($stmt_block);

    auto arguments = vector<shared_ptr<Argument>>();
    auto results = vector<shared_ptr<Result>>();
    $$ = new Function(ident, arguments, results);

    $$->addStatements(*statements);
  }

%type <function> function;
function
  : {ctx->scope();} function_header stmt_block {ctx->unscope();} BLOCKEND{
    auto statements = unique_ptr<vector<shared_ptr<IRNode>>>($stmt_block);
    $$ = $function_header;
    $$->addStatements(*statements);
  }

%type <function> function_header;
function_header
  : "func" IDENT arguments results {
    std::string ident = convertAndFree($IDENT);
    auto arguments = unique_ptr<vector<shared_ptr<Argument>>>($arguments);
    auto results = unique_ptr<vector<shared_ptr<Result>>>($results);

    $$ = new Function(ident, *arguments, *results);
    std::set<std::string> argumentNames;
    for (auto argument : *arguments) {
      ctx->addSymbol(argument->getName(), argument, NULL);
      argumentNames.insert(argument->getName());
    }

    for (auto result : *results) {
      std::shared_ptr<Expression> readExpr(NULL);
      if (argumentNames.find(result->getName()) != argumentNames.end()) {
        readExpr = ctx->getSymbol(result->getName()).getReadExpr();
      }

      ctx->addSymbol(result->getName(), readExpr, result);
    }
  }

%code requires {
  namespace {
  struct FormalData {
    std::string name;
    std::shared_ptr<simit::ir::Type> type;
    FormalData(const std::string &name,
               const std::shared_ptr<simit::ir::Type> &type)
        : name(name), type(type){}
  };
  }
};

%union {
  FormalData                                 *Formal;
  util::OwnershipVector<FormalData*>         *Formals;
  std::vector<std::shared_ptr<ir::Argument>> *Arguments;
  std::vector<std::shared_ptr<ir::Result>>   *Results;
};

%type <Arguments> arguments;
arguments
  : "(" ")" {
    $$ = new vector<shared_ptr<Argument>>();
  }
  | "(" formal_list ")" {
    $$ = new vector<shared_ptr<Argument>>();
    for (auto formal : *$formal_list) {
      auto result = new Argument(formal->name, formal->type);
      $$->push_back(shared_ptr<Argument>(result));
    }
    delete $formal_list;
 }

%type <Results> results;
results
  : /* empty */ {
    $$ = new vector<shared_ptr<Result>>();
    $$->push_back(shared_ptr<Result>(new Result("asd", NULL)));
  }
  | RARROW "(" formal_list ")" {
    $$ = new vector<shared_ptr<Result>>();
    for (auto formal : *$formal_list) {
      auto result = new Result(formal->name, formal->type);
      $$->push_back(shared_ptr<Result>(result));
    }
    delete $formal_list;
  }

%type <Formals> formal_list;
formal_list
  : formal_decl {
    $$ = new simit::util::OwnershipVector<FormalData *>();
    $$->push_back($formal_decl);
  }
  | formal_list "," formal_decl {
    $$->push_back($formal_decl);
  }

%type <Formal> formal_decl;
formal_decl
  : IDENT ":" type {
    std::string ident = convertAndFree($IDENT);
    std::shared_ptr<Type> type = convertAndDelete($type);
    $$ = new FormalData(ident, type);
  }

// Statements
%type<IRNodes> stmt_block;
stmt_block
  : /* empty */ {
    $$ = new vector<shared_ptr<IRNode>>();
  }
  | stmt_block stmt {
    $$ = $1;
    if ($stmt == NULL) break;  // TODO: Remove check
    $$->insert($$->end(), $stmt->begin(), $stmt->end());
    delete $stmt;
  }

%type<IRNodes> stmt;
stmt
  : const_stmt
  | return_stmt
  | assign_stmt
  | expr_stmt
  | if_stmt

%type<IRNodes> const_stmt;
const_stmt
  : "const" IDENT ":" tensor_type "=" tensor_literal ";" {
    std::string ident = convertAndFree($IDENT);
    std::shared_ptr<TensorType> tensorType = convertAndDelete($tensor_type);

    auto literal = shared_ptr<Literal>(*$tensor_literal);
    delete $tensor_literal;

    assert(literal->getType()->isTensor() && "Set literals not supported yet");
    auto literalType = literal->getType();

    literal->setName(ident);

    // If tensor_type is a 1xn matrix and $tensor_literal is a vector then we
    // cast $tensor_literal to a 1xn matrix.
    TensorType *literalTensorType = tensorTypePtr(literalType);
    if (tensorType->getOrder() == 2 && literalTensorType->getOrder() == 1) {
      literal->cast(tensorType);
    }

    // Typecheck: value and literal types must be equivalent.
    CHECK_TYPE_EQUALITY(*tensorType, *literal->getType(), @2);

    ctx->addSymbol(literal->getName(), literal);

    $$ = new vector<shared_ptr<IRNode>>();
    $$->push_back(literal);
  }

%type<IRNodes> return_stmt;
return_stmt
  : "return" ";" {
    $$ = NULL;
  }

%type<IRNodes> assign_stmt;
assign_stmt
  : write_expr_list "=" expr_list ";" {
    auto lhsList = unique_ptr<vector<WriteInfo*>>($write_expr_list);
    auto rhsList = unique_ptr<vector<shared_ptr<Expression>>>($expr_list);

    $$ = new vector<shared_ptr<IRNode>>();

    if (lhsList->size() > rhsList->size()) {
      // TODO: Handle maps and then reintroduce this error
      // REPORT_ERROR("too few expressions assigned to too many variables", @2);
      break;
    }
    else if (lhsList->size() < rhsList->size()) {
      REPORT_ERROR("too many expressions assigned to too few variables", @2);
    }

    auto lhsIter = lhsList->begin();
    auto rhsIter = rhsList->begin();
    for (; lhsIter != lhsList->end(); ++lhsIter, ++rhsIter) {
      unique_ptr<WriteInfo> lhs(*lhsIter);
      shared_ptr<Expression> &rhs = *rhsIter;

      if (rhs == NULL) continue;

      switch (lhs->kind) {
        case WriteInfo::Kind::VARIABLE: {
          std::string variableName = *lhs->variableName;

          // TODO: Remove check
          if (!ctx->hasSymbol(variableName)) continue;

          assert(ctx->hasSymbol(variableName));

          const RWExprPair &varExprPair = ctx->getSymbol(variableName);
          assert(varExprPair.isWritable());

          shared_ptr<Expression> lhsTensor = varExprPair.getWriteExpr();
          if (auto result = dynamic_pointer_cast<Result>(lhsTensor)) {
            CHECK_TYPE_EQUALITY(*result->getType(), *rhs->getType(), @2);
            rhs->setName(result->getName());
            result->addValue(rhs);
            $$->push_back(rhs);
          }
          else {
            NOT_SUPPORTED_YET;
          }
          break;
        }
        case WriteInfo::Kind::FIELD: {
          std::shared_ptr<FieldWrite> fieldWrite(*lhs->fieldWrite);
          fieldWrite->setValue(rhs);

          auto result = dynamic_pointer_cast<Result>(fieldWrite->getTarget());
          if (result) {
            result->addValue(fieldWrite);
            $$->push_back(fieldWrite);
          }

          break;
        }
        case WriteInfo::Kind::TENSOR: {
          std::shared_ptr<TensorWrite> tensorWrite(*lhs->tensorWrite);
          tensorWrite->setValue(rhs);

          auto result = dynamic_pointer_cast<Result>(tensorWrite->getTensor());
          if (result){
            result->addValue(tensorWrite);
            $$->push_back(tensorWrite);
          }

          break;
        }
      }
    }
  }

%type<IRNodes> expr_stmt;
expr_stmt
  : expr ";" {
    $$ = NULL;
  }
  | ";" {
    $$ = NULL;
  }

%type<IRNodes> if_stmt;
if_stmt
  : "if" expr stmt_block else_clauses BLOCKEND {
    $$ = NULL;
    delete $2;
    delete $3;
  }

else_clauses
  : /* empty */
  | elif_clauses "else" stmt_block {
    delete $3;
  }

elif_clauses
  : /* empty */
  | elif_clauses "elif" expr stmt_block {
    delete $3;
    delete $4;
  }


// Expressions
%union {
  std::shared_ptr<ir::Expression>              *expression;
  std::vector<std::shared_ptr<ir::Expression>> *expressions;
};

%type <expression> expr;
expr
  : ident_expr
  | paren_expr
  | literal_expr
  | linear_algebra_expr
  | boolean_expr
  | field_read_expr
  | call_or_tensor_read_expr
  | range_expr
  | map_expr


// Read Ident Expression
%type <expression> ident_expr;
ident_expr
  : IDENT {
    string ident = convertAndFree($IDENT);

    if (!ctx->hasSymbol(ident)) { $$=NULL; break; } // TODO: Remove check

    if (!ctx->hasSymbol(ident)) {
      REPORT_ERROR(ident + " is not defined in scope", @1);
    }

    const RWExprPair &rwExprPair = ctx->getSymbol(ident);
    if (!rwExprPair.isReadable()) {
      REPORT_ERROR(ident + " is not readable", @1);
    }

    $$ = new shared_ptr<Expression>(rwExprPair.getReadExpr());
  }


// Parenthesis Expression
%type <expression> paren_expr;
paren_expr
  : "(" expr ")" {
    if ($2 == NULL) { $$ = NULL; break; } // TODO: Remove check
    $$ = $2;
  }


// Linear Algebra Expressions
%union {
  ir::IndexExpr::Operator         binop;
  std::shared_ptr<ir::IndexExpr> *indexExpr;

};
%destructor {} <binop>;

%type <indexExpr> linear_algebra_expr;
linear_algebra_expr
  : "-" expr %prec NEG {
    if ($2 == NULL) { $$ = NULL; break; } // TODO: Remove check

    std::shared_ptr<Expression> expr = convertAndDelete($2);
    CHECK_IS_TENSOR(expr, @2);

    $$ = new shared_ptr<IndexExpr>(unaryElwiseExpr(IndexExpr::NEG, expr));
  }
  | expr elwise_binary_op expr {  // + - .* ./
    if ($1 == NULL || $3 == NULL) { $$ = NULL; break; } // TODO: Remove check

    std::shared_ptr<Expression> l = convertAndDelete($1);
    std::shared_ptr<Expression> r = convertAndDelete($3);

    CHECK_IS_TENSOR(l, @1);
    CHECK_IS_TENSOR(r, @3);

    BINARY_ELWISE_TYPE_CHECK(l->getType(), r->getType(), @2);
    $$ = new shared_ptr<IndexExpr>(binaryElwiseExpr(l, $2, r));
  }
  | expr "*" expr {
    if ($1 == NULL || $3 == NULL) { $$ = NULL; break; } // TODO: Remove check

    std::shared_ptr<Expression> l = convertAndDelete($1);
    std::shared_ptr<Expression> r = convertAndDelete($3);

    CHECK_IS_TENSOR(l, @1);
    CHECK_IS_TENSOR(r, @3);

    TensorType *ltype = tensorTypePtr(l->getType());
    TensorType *rtype = tensorTypePtr(r->getType());

    // Scale
    if (ltype->getOrder()==0 || rtype->getOrder()==0) {
      $$ = new shared_ptr<IndexExpr>(binaryElwiseExpr(l, IndexExpr::MUL, r));
    }
    // Vector-Vector Multiplication (inner and outer product)
    else if (ltype->getOrder() == 1 && rtype->getOrder() == 1) {
      // Inner product
      if (!ctx->isColumnVector(*l->getType())) {
        if (!ctx->isColumnVector(*r->getType())) {
          REPORT_ERROR("cannot multiply two row vectors", @2);
        }
        if (*l->getType() != *r->getType()) {
          REPORT_TYPE_MISSMATCH(*l->getType(), *r->getType(), @2);
        }
        $$ = new shared_ptr<IndexExpr>(innerProduct(l, r));
      }
      // Outer product (l is a column vector)
      else {
        if (ctx->isColumnVector(*r->getType())) {
          REPORT_ERROR("cannot multiply two column vectors", @2);
        }
        if (*l->getType() != *r->getType()) {
          REPORT_TYPE_MISSMATCH(*l->getType(), *r->getType(), @2);
        }
        $$ = new shared_ptr<IndexExpr>(outerProduct(l, r));
      }
    }
    // Matrix-Vector
    else if (ltype->getOrder() == 2 && rtype->getOrder() == 1) {
      if (ltype->getDimensions()[1] != rtype->getDimensions()[0]){
        REPORT_TYPE_MISSMATCH(*l->getType(), *rtype, @2);
      }
      $$ = new shared_ptr<IndexExpr>(gemv(l, r));
    }
    // Vector-Matrix
    else if (ltype->getOrder() == 1 && rtype->getOrder() == 2) {
      if (ltype->getDimensions()[0] != rtype->getDimensions()[0]){
        REPORT_TYPE_MISSMATCH(*ltype, *rtype, @2);
      }
      $$ = new shared_ptr<IndexExpr>(gevm(l,r));
    }
    // Matrix-Matrix
    else if (ltype->getOrder() == 2 && rtype->getOrder() == 2) {
      if (ltype->getDimensions()[1] != rtype->getDimensions()[0]){
        REPORT_TYPE_MISSMATCH(*ltype, *rtype, @2);
      }
      $$ = new shared_ptr<IndexExpr>(gemm(l,r));
    }
    else {
      REPORT_ERROR("cannot multiply >2-order tensors using *", @2);
      $$ = NULL;
    }
  }
  | expr "/" expr {
    if ($1 == NULL || $3 == NULL) { $$ = NULL; break; } // TODO: Remove check
    $$ = NULL;
    delete $1;
    delete $3;
  }
  | expr "'" {
    if ($1 == NULL) { $$ = NULL; break; } // TODO: Remove check

    auto expr = shared_ptr<Expression>(*$1);
    delete $1;

    CHECK_IS_TENSOR(expr, @1);

    TensorType *type = tensorTypePtr(expr->getType());

    switch (type->getOrder()) {
      case 0:
        // OPT: This might lead to redundant code to be removed in later pass
        $$ = new shared_ptr<IndexExpr>(unaryElwiseExpr(IndexExpr::NONE, expr));
        break;
      case 1:
        // OPT: This might lead to redundant code to be removed in later pass
        $$ = new shared_ptr<IndexExpr>(unaryElwiseExpr(IndexExpr::NONE, expr));
        if (!ctx->isColumnVector(*expr->getType())) {
          ctx->toggleColumnVector(*(*$$)->getType());
        }
        break;
      case 2:
        $$ = new shared_ptr<IndexExpr>(transposeMatrix(expr));
        break;
      default:
        REPORT_ERROR("cannot transpose >2-order tensors using '", @1);
        $$ = NULL;
    }
  }
  | expr "^" expr {
    $$ = NULL;
    delete $1;
    delete $3;
  }
  | expr "\\" expr {  // Solve
    if ($1 == NULL || $3 == NULL) { $$ = NULL; break; } // TODO: Remove check
    $$ = NULL;
    delete $1;
    delete $3;
  }

%type <binop> elwise_binary_op;
elwise_binary_op
  : "+"  { $$ = IndexExpr::ADD; }
  | "-"  { $$ = IndexExpr::SUB; }
  | ".*" { $$ = IndexExpr::MUL; }
  | "./" { $$ = IndexExpr::DIV; }


// Boolean Expressions
%type <expression> boolean_expr;
boolean_expr
  : expr "==" expr {
    if ($1 == NULL || $3 == NULL) { $$ = NULL; break; } // TODO: Remove check
    $$ = NULL;
    delete $1;
    delete $3;
  }
  | expr "!=" expr {
    if ($1 == NULL || $3 == NULL) { $$ = NULL; break; } // TODO: Remove check
    $$ = NULL;
    delete $1;
    delete $3;
  }
  | expr "<"  expr {
    if ($1 == NULL || $3 == NULL) { $$ = NULL; break; } // TODO: Remove check
    $$ = NULL;
    delete $1;
    delete $3;
  }
  | expr ">"  expr {
    if ($1 == NULL || $3 == NULL) { $$ = NULL; break; } // TODO: Remove check
    $$ = NULL;
    delete $1;
    delete $3;
  }
  | expr "<=" expr {
    if ($1 == NULL || $3 == NULL) { $$ = NULL; break; } // TODO: Remove check
    $$ = NULL;
    delete $1;
    delete $3;
  }
  | expr ">=" expr {
    if ($1 == NULL || $3 == NULL) { $$ = NULL; break; } // TODO: Remove check
    $$ = NULL;
    delete $1;
    delete $3;
  }


// Field Read Expressions
%union {
  std::shared_ptr<ir::FieldRead> *fieldRead;
};

%type <fieldRead> field_read_expr;
field_read_expr
  : set_read_expr "." IDENT {
    if ($1 == NULL || $3 == NULL) { $$ = NULL; break; } // TODO: Remove check
    if ((*$1)->getType() == NULL) { $$ = NULL; break; } // TODO: Remove check

    std::shared_ptr<Expression> elemOrSet = convertAndDelete($set_read_expr);
    std::string fieldName = convertAndFree($IDENT);

    auto type = elemOrSet->getType();
    assert(type);
    if (!(type->isElement() || type->isSet())) {
      std::stringstream errorStr;
      errorStr << "only elements and sets have fields";
      REPORT_ERROR(errorStr.str(), @1);
    }

    $$ = new shared_ptr<FieldRead>(new FieldRead(elemOrSet, fieldName));
  }

%type <expression> set_read_expr;
set_read_expr
  : ident_expr
  | paren_expr
  | call_expr


// Call and Tensor Read Expressions
%union {
  std::shared_ptr<ir::Call>       *call;
  std::shared_ptr<ir::TensorRead> *tensorRead;
};

%type <expression> call_or_tensor_read_expr;
call_or_tensor_read_expr
  : IDENT "(" expr_list_or_empty ")" {
    std::string name = convertAndFree($1);
    auto indices =
        unique_ptr<vector<shared_ptr<Expression>>>($expr_list_or_empty);

    if (ctx->hasSymbol(name)) {
      const RWExprPair &exprPair = ctx->getSymbol(name);
      if (!exprPair.isReadable()) {
        REPORT_ERROR(name + " is not readable", @1);
      }

      auto tensorExpr = exprPair.getReadExpr();
      $$ = new shared_ptr<Expression>(new TensorRead(tensorExpr, *indices));
    }
    // TODO: elseif function
    else {
      REPORT_ERROR(name + " is not defined in scope", @1);
    }

  }
  | field_read_expr "(" expr_list_or_empty ")" {
    $$ = NULL;
  }

%type<call> call_expr;
call_expr
  : IDENT "(" expr_list_or_empty ")" {
    std::string name = convertAndFree($1);
    auto actuals =
        unique_ptr<vector<shared_ptr<Expression>>>($expr_list_or_empty);
    auto call = new Call(name, *actuals);
    $$ = new std::shared_ptr<Call>(call);
  }

%type <expressions> expr_list_or_empty;
expr_list_or_empty
  : /* empty */ {
    $$ = new vector<shared_ptr<Expression>>();
  }
  | expr_list {
    $$ = $expr_list;
  }

%type <expressions> expr_list;
expr_list
  : expr {
    $$ = new std::vector<std::shared_ptr<Expression>>();
    if ($expr == NULL) break;  // TODO: Remove check
    $$->push_back(*$expr);
    delete $expr;
  }
  | expr_list "," expr {
    $$ = $1;
    if ($expr == NULL) break;  // TODO: Remove check
    $$->push_back(*$expr);
    delete $expr;
  }


// Range Expressions
%type <expression> range_expr;
range_expr
  : expr ":" expr {
    if ($1 == NULL || $3 == NULL) { $$ = NULL; break; } // TODO: Remove check
    $$ = NULL;
    delete $1;
    delete $3;
  }


// Map Expressions
%type <expression> map_expr;
map_expr
  : "map" IDENT "to" IDENT with reduce {
    string function($2);
    string target($4);
    free((void*)$2);
    free((void*)$4);
    $$ = NULL;
  }

with
  : /* empty */
  | "with" IDENT {
    std::string neighbor = convertAndFree($IDENT);
  }

reduce
  : /* empty */
  | "reduce" reduction_op

reduction_op
  : "+"
  | "*"


// Write Expressions
%code requires {
  struct WriteInfo {
    enum Kind { VARIABLE, FIELD, TENSOR };
    Kind kind;
    union {
      std::string                             *variableName;
      std::shared_ptr<simit::ir::FieldWrite>  *fieldWrite;
      std::shared_ptr<simit::ir::TensorWrite> *tensorWrite;
    };
    WriteInfo(const std::string &variableName) : kind(VARIABLE) {
      this->variableName = new std::string(variableName);
    }
    WriteInfo(std::shared_ptr<simit::ir::FieldWrite> *write) : kind(FIELD) {
      this->fieldWrite = write;
    }
    WriteInfo(std::shared_ptr<simit::ir::TensorWrite> *write) : kind(TENSOR) {
      this->tensorWrite = write;
    }

    ~WriteInfo() {
      switch (kind) {
        case Kind::VARIABLE:
          delete variableName;
          break;
        case Kind::FIELD:
          delete fieldWrite;
          break;
        case Kind::TENSOR:
          delete tensorWrite;
          break;
      }
    }
  };
};

%union {
  std::vector<WriteInfo*>          *writeinfos;
  WriteInfo                        *writeinfo;
  std::shared_ptr<ir::FieldWrite>  *fieldWrite;
  std::shared_ptr<ir::TensorWrite> *tensorWrite;
};

%type<writeinfos> write_expr_list;
write_expr_list
  : write_expr {
    $$ = new vector<WriteInfo*>();
    if ($write_expr == NULL) break;  // TODO: Remove check
    $$->push_back($write_expr);
  }
  | write_expr_list "," write_expr {
    $$ = $1;
    if ($write_expr == NULL) break;  // TODO: Remove check
    $$->push_back($write_expr);
  }

%type <writeinfo> write_expr;
write_expr
  : IDENT {
    std::string name = convertAndFree($IDENT);
    $$ = new WriteInfo(name);
  }
  | field_write_expr {
    $$ = new WriteInfo($field_write_expr);
  }
  | tensor_write_expr {
    $$ = new WriteInfo($tensor_write_expr);
  }

%type <fieldWrite> field_write_expr;
field_write_expr
  : IDENT "." IDENT {
    string setName = convertAndFree($1);
    string fieldName = convertAndFree($3);

    if(!ctx->hasSymbol(setName)) { $$=NULL; break; } // TODO: Remove check

    if (!ctx->hasSymbol(setName)) {
      REPORT_ERROR(setName + " is not defined in scope", @1);
    }

    const RWExprPair &setExprPair = ctx->getSymbol(setName);
    if (!setExprPair.isWritable()) {
      REPORT_ERROR(setName + " is not writable", @1);
    }

    auto setExpr = setExprPair.getWriteExpr();
    $$ = new shared_ptr<FieldWrite>(new FieldWrite(setExpr, fieldName));
  }
  | paren_expr "." IDENT {
    $$ = NULL;
  }

%type <tensorWrite> tensor_write_expr;
tensor_write_expr
  : IDENT "(" expr_list ")" {
    std::string tensorName = convertAndFree($1);
    auto indices = unique_ptr<vector<shared_ptr<Expression>>>($expr_list);

    if(!ctx->hasSymbol(tensorName)) { $$=NULL; break; } // TODO: Remove check

    if (!ctx->hasSymbol(tensorName)) {
      REPORT_ERROR(tensorName + " is not defined in scope", @1);
    }

    const RWExprPair &tensorExprPair = ctx->getSymbol(tensorName);
    if (!tensorExprPair.isWritable()) {
      REPORT_ERROR(tensorName + " is not writable", @1);
    }

    auto tensorExpr = tensorExprPair.getWriteExpr();
    $$ = new shared_ptr<TensorWrite>(new TensorWrite(tensorExpr, *indices));
  }
  | field_write_expr "(" expr_list ")" {
    // TODO
    $$ = NULL;
  }


// Types
%union {
  std::shared_ptr<ir::Type>        *type;
  std::shared_ptr<ir::ElementType> *elementType;
  std::shared_ptr<ir::SetType>     *setType;
  std::shared_ptr<ir::TupleType>   *tupleType;
  std::shared_ptr<ir::TensorType>  *tensorType;

  std::vector<std::shared_ptr<ir::ElementType>> *elementTypes;

  std::vector<ir::IndexDomain> *IndexDomains;
  std::vector<ir::IndexSet>    *IndexSets;
  ir::IndexSet                 *indexSet;
  ComponentType                 componentType;
};
%destructor {} <componentType>;

%type <IndexDomains>  nested_dimensions;
%type <IndexSets>     dimensions;
%type <indexSet>      dimension;
%type <componentType> component_type;

%type <type> type;
type
  : element_type {
    $$ = reinterpret_cast<std::shared_ptr<ir::Type>*>($element_type);
  }
  | set_type {
    $$ = reinterpret_cast<std::shared_ptr<ir::Type>*>($set_type);
  }
  | tuple_type {
    $$ = reinterpret_cast<std::shared_ptr<ir::Type>*>($tuple_type);
  }
  | tensor_type {
    $$ = reinterpret_cast<std::shared_ptr<ir::Type>*>($tensor_type);
  }

%type <elementType> element_type;
element_type
  : IDENT {
    std::string name = convertAndFree($IDENT);
    $$ = new std::shared_ptr<ElementType>(ctx->getElementType(name));
  }

%type <setType> set_type;
set_type
  : "set" "{" element_type "}" {
    std::shared_ptr<ElementType> elementType = convertAndDelete($element_type);
    $$ = new std::shared_ptr<SetType>(new SetType(elementType));
  }
  | "set" "{" element_type "}" "(" endpoints ")" {
    $$ = NULL;
  }

%type <tupleType> tuple_type;
tuple_type
  : "(" tuple_element_types ")" {
    $$ = new std::shared_ptr<TupleType>(new TupleType(*$tuple_element_types));
    delete $tuple_element_types;
  }

%type <elementTypes> tuple_element_types;
tuple_element_types
  : tuple_element_type {
    $$ = $1;
  }
  | tuple_element_types "," tuple_element_type {
    $$ = $1;
    $$->insert($$->begin(), $3->begin(), $3->end());
    delete $3;
  }

%type <elementTypes> tuple_element_type;
tuple_element_type
  : element_type {
    $$ = new vector<shared_ptr<ElementType>>;
    $$->push_back(*$element_type);
    delete $element_type;
  }
  | element_type "*" INT_LITERAL {
    auto elementType = convertAndDelete($element_type);

    if ($INT_LITERAL<1) {
      REPORT_ERROR("Must be 1 or greater", @3);
    }

    $$ = new vector<shared_ptr<ElementType>>;
    for (int i=0; i < $INT_LITERAL; ++i) {
      $$->push_back(elementType);
    }
    delete $element_type;
  }

%type <tensorType> tensor_type;
tensor_type
  : component_type {
    $$ = new std::shared_ptr<TensorType>(new TensorType($component_type));
  }
  | "tensor" nested_dimensions "(" component_type ")" {
    $$ = new std::shared_ptr<TensorType>(new TensorType($component_type,
                                                        *$nested_dimensions));
    delete $nested_dimensions;
  }
  | "tensor" nested_dimensions "(" component_type ")" "'" {
    $$ = new std::shared_ptr<TensorType>(new TensorType($component_type,
                                                        *$nested_dimensions));
    ctx->toggleColumnVector(**$$);
    delete $nested_dimensions;
  }

nested_dimensions
  : /* empty */ {
    $$ = new std::vector<IndexDomain>();
  }
  | nested_dimensions "[" dimensions "]" {
    $$ = $1;

    auto parentDims = $$;
    auto childDims = unique_ptr<std::vector<IndexSet>>($dimensions);

    // If there are no previous dimensions then create IndexDomains
    if (parentDims->size() == 0) {
      for (auto &dim : *childDims) {
        UNUSED(dim);
        parentDims->push_back(IndexDomain());
      }
    }

    // Handle case where there are more child than parent dimensions
    if (childDims->size() > parentDims->size()) {
      for (size_t i=0; i < childDims->size() - parentDims->size(); ++i) {
        size_t numNestings = (*parentDims)[0].getFactors().size();
        std::vector<IndexSet> indexSets(numNestings, IndexSet(1));
        parentDims->push_back(IndexDomain(indexSets));
      }
    }

    // Handle case where there are more parent than child dimensions
    if (parentDims->size() > childDims->size()) {
      for (size_t i=0; i < parentDims->size() - childDims->size(); ++i) {
        childDims->push_back(IndexSet(1));
      }
    }

    // Multiply each dimension with the corresponding dimension in the shape.
    assert(childDims->size() == parentDims->size());
    for (size_t i=0; i<$$->size(); ++i) {
      (*parentDims)[i] = (*parentDims)[i] * IndexDomain((*childDims)[i]);
    }
  }

dimensions
  : dimension {
    $$ = new std::vector<IndexSet>();
    $$->push_back(*$dimension);
    delete $dimension;
  }
  | dimensions "," dimension {

    $$ = $1;
    $$->push_back(*$dimension);
    delete $dimension;
  }

dimension
  : INT_LITERAL {
    $$ = new IndexSet($INT_LITERAL);
  }
  | IDENT {
    string ident = convertAndFree($IDENT);
    $$ = new IndexSet(ident);
  }
  | "*" {
    $$ = new IndexSet();
  }

component_type
  : INT {
    $$ = ComponentType::INT;
  }
  | FLOAT {
    $$ = ComponentType::FLOAT;
  }


// Literals
%code requires {
  namespace {
    template <typename T>
    class TensorValues {
     public:
      TensorValues() : dimSizes(1) {};

      void addValue(const T &val) {
        values.push_back(val);
        dimSizes[dimSizes.size()-1]++;
      }
      void addDimension() { dimSizes.push_back(1); }

      bool dimensionsMatch(const TensorValues<T> &other, std::string *errors) {
        assert(errors != NULL);
        std::string mismatchError = "missmatched dimension sizes";
        if (dimSizes.size()-1 != other.dimSizes.size()) {
          *errors = mismatchError;
          return false;
        }

        for (unsigned int i=0; i<dimSizes.size()-1; ++i) {
          if (dimSizes[i] != other.dimSizes[i]) {
            *errors = mismatchError;
            return false;
          }
        }
        return true;
      }

      void merge(const TensorValues<T> &other) {
        values.insert(values.end(), other.values.begin(), other.values.end());
        dimSizes[dimSizes.size()-1]++;
      }

      std::vector<unsigned int> dimSizes;
      std::vector<T>            values;
    };
  }
};

%union {
  std::shared_ptr<ir::Literal> *TensorLiteral;
  TensorValues<double>         *TensorDoubleValues;
  TensorValues<int>            *TensorIntValues;
};

%type <TensorLiteral> literal;
%type <TensorLiteral> tensor_literal;
%type <TensorLiteral> dense_tensor_literal;
%type <TensorLiteral> scalar_literal;

%type <TensorDoubleValues> float_dense_tensor_literal;
%type <TensorDoubleValues> float_dense_ndtensor_literal;
%type <TensorDoubleValues> float_dense_matrix_literal;
%type <TensorDoubleValues> float_dense_vector_literal;

%type <TensorIntValues> int_dense_tensor_literal;
%type <TensorIntValues> int_dense_ndtensor_literal;
%type <TensorIntValues> int_dense_matrix_literal;
%type <TensorIntValues> int_dense_vector_literal;

literal_expr
  : tensor_literal

tensor_literal
  : dense_tensor_literal
  | dense_tensor_literal "'" {
    $$ = $1;
    ctx->toggleColumnVector(*(*$$)->getType());
  }
  | scalar_literal

dense_tensor_literal
  : "[" float_dense_tensor_literal "]" {
    auto values = unique_ptr<TensorValues<double>>($2);
    auto isps = std::vector<IndexDomain>(values->dimSizes.rbegin(),
                                             values->dimSizes.rend());
    auto type = new TensorType(ComponentType::FLOAT, isps);
    auto literal = new Literal(shared_ptr<TensorType>(type), // TODO: <Type>
                               values->values.data());
    $$ = new shared_ptr<Literal>(literal);
  }
  | "[" int_dense_tensor_literal "]" {
    auto values = unique_ptr<TensorValues<int>>($2);
    auto isps = std::vector<IndexDomain>(values->dimSizes.rbegin(),
                                             values->dimSizes.rend());
    auto type = new TensorType(ComponentType::INT, isps);
    auto literal = new Literal(shared_ptr<TensorType>(type), // TODO: <Type>
                               values->values.data());
    $$ = new shared_ptr<Literal>(literal);
  }

float_dense_tensor_literal
  : float_dense_matrix_literal {
    // If the matrix has only one column then we discard that dimension and
    // treat it as a vector.
    if ($1->dimSizes[$1->dimSizes.size()-1] == 1) {
      $1->dimSizes.pop_back();
    }
  }
  | float_dense_ndtensor_literal

float_dense_ndtensor_literal
  : "[" float_dense_matrix_literal "]" {
    $$ = $2;
    $$->addDimension();
  }
  | float_dense_ndtensor_literal "," "[" float_dense_matrix_literal "]" {
    auto  left = unique_ptr<TensorValues<double>>($1);
    auto right = unique_ptr<TensorValues<double>>($4);

    string errorStr;
    if(!left->dimensionsMatch(*right, &errorStr)) {
      REPORT_ERROR(errorStr, @2);
    }
    left->merge(*right);
    $$ = left.release();
  }

float_dense_matrix_literal
  : float_dense_vector_literal {
    $$ = $1;
    $$->addDimension();
  }
  | float_dense_matrix_literal ";" float_dense_vector_literal {
    auto  left = unique_ptr<TensorValues<double>>($1);
    auto right = unique_ptr<TensorValues<double>>($3);

    string errorStr;
    if(!left->dimensionsMatch(*right, &errorStr)) {
      REPORT_ERROR(errorStr, @2);
    }

    left->merge(*right);
    $$ = left.release();
  }

float_dense_vector_literal
  : FLOAT_LITERAL {
    $$ = new TensorValues<double>();
    $$->addValue($1);
  }
  | float_dense_vector_literal "," FLOAT_LITERAL {
    $$ = $1;
    $$->addValue($3);
  }

int_dense_tensor_literal
  : int_dense_matrix_literal {
    // If the matrix has only one column then we discard that dimension and
    // treat it as a vector.
    if ($1->dimSizes[$1->dimSizes.size()-1] == 1) {
      $1->dimSizes.pop_back();
    }
  }
  | int_dense_ndtensor_literal

int_dense_ndtensor_literal
  : "[" int_dense_matrix_literal "]" {
    $$ = $2;
    $$->addDimension();
  }
  | int_dense_ndtensor_literal "," "[" int_dense_matrix_literal "]" {
    auto  left = unique_ptr<TensorValues<int>>($1);
    auto right = unique_ptr<TensorValues<int>>($4);

    string errorStr;
    if(!left->dimensionsMatch(*right, &errorStr)) {
      REPORT_ERROR(errorStr, @2);
    }
    left->merge(*right);
    $$ = left.release();
  }

int_dense_matrix_literal
  : int_dense_vector_literal {
    $$ = $1;
    $$->addDimension();
  }
  | int_dense_matrix_literal ";" int_dense_vector_literal {
    auto  left = unique_ptr<TensorValues<int>>($1);
    auto right = unique_ptr<TensorValues<int>>($3);

    string errorStr;
    if(!left->dimensionsMatch(*right, &errorStr)) {
      REPORT_ERROR(errorStr, @2);
    }

    left->merge(*right);
    $$ = left.release();
  }

int_dense_vector_literal
  : INT_LITERAL {
    $$ = new TensorValues<int>();
    $$->addValue($1);
  }
  | int_dense_vector_literal "," INT_LITERAL {
    $$ = $1;
    $$->addValue($3);
  }

scalar_literal
  : INT_LITERAL {
    auto scalarType = new TensorType(ComponentType::INT);
    auto literal = new Literal(std::shared_ptr<TensorType>(scalarType), &$1);
    $$ = new shared_ptr<Literal>(literal);
  }
  | FLOAT_LITERAL {
    auto scalarType = new TensorType(ComponentType::FLOAT);
    auto literal = new Literal(std::shared_ptr<TensorType>(scalarType), &$1);
    $$ = new shared_ptr<Literal>(literal);
  }

// Tests
%union { ir::Test *test; };
%type <test> test;
test
  : "%!" call_expr "==" tensor_literal ";" {
    auto call = shared_ptr<Call>(*$call_expr);
    auto expected = shared_ptr<Literal>(*$tensor_literal);
    delete $call_expr;
    delete $tensor_literal;

    std::vector<std::shared_ptr<Literal>> literalArgs;
    literalArgs.reserve(call->getArguments().size());
    for (auto &arg : call->getArguments()) {
      std::shared_ptr<Literal> litarg = dynamic_pointer_cast<Literal>(arg);
      if (!litarg) {
        REPORT_ERROR("function calls in tests must have literal arguments", @1);
      }
      literalArgs.push_back(litarg);
    }
    assert(literalArgs.size() == call->getArguments().size());

    std::vector<std::shared_ptr<Literal>> expecteds;
    expecteds.push_back(expected);
    $$ = new Test(call->getName(), literalArgs, expecteds);
  }

%%
