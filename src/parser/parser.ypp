%require "3.0"
%language "C++"

%defines
%define api.namespace { simit::internal }
%define parser_class_name { Parser }
%define parse.error verbose
%locations

%code requires {
  namespace simit {
  namespace internal {
    class Scanner;
    class ProgramContext;
  }}

  #include <vector>

  #include "util.h"
  #include "ir.h"
  #include "error.h"
  #include "types.h"
  #include "ir_builder.h"
}

%parse-param { Scanner *scanner };
%parse-param { ProgramContext *ctx };
%parse-param { std::vector<ParseError> *errors };

%code {
  #include <stdlib.h>
  #include <iostream>
  #include <map>
  #include <set>
  #include <algorithm>

  #include "program_context.h"
  #include "scanner.h"

  using namespace std;
  using namespace simit::internal;
  using namespace simit::ir;

  std::string typeString(const Type &type) {
    std::stringstream ss;
    ss << type;
    std::string str = ss.str();
    if (type.isTensor() && type.toTensor()->isColumnVector) {
      str += "'";
    }
    return str;
  }

  #define REPORT_ERROR(msg, loc)  \
    do {                          \
      error((loc), (msg));        \
      YYERROR;                    \
    } while (0)

  #define REPORT_TYPE_MISSMATCH(t1, t2, loc)                          \
    do {                                                              \
      std::stringstream errorStr;                                     \
      errorStr << "type missmatch (" <<                               \
                  typeString(t1) << " and " << typeString(t2) << ")"; \
      REPORT_ERROR(errorStr.str(), loc);                              \
    } while (0)

  #define REPORT_INDEX_VARIABLE_MISSMATCH(numIndexVars, order, loc) \
    do {                                                            \
      REPORT_ERROR("wrong number of index variables (" +            \
                    to_string(numIndexVars) +                       \
                    " index variables, but tensor order is " +      \
                    to_string(order), loc);                         \
      } while (0)

  void Parser::error(const Parser::location_type &loc,
                           const std::string &msg) {
    errors->push_back(ParseError(loc.begin.line, loc.begin.column,
                            loc.end.line, loc.end.column, msg));
  }

  #undef yylex
  #define yylex scanner->lex

  inline std::string convertAndFree(const char *str) {
    std::string result = std::string(str);
    free((void*)str);
    return result;
  }

  template <typename T>
  inline T convertAndDelete(T *obj) {
    auto result = T(*obj);
    delete obj;
    return result;
  }

  void transposeVector(Expr vec) {
    iassert(vec.type().isTensor());
    const TensorType *ttype = vec.type().toTensor();
    iassert(ttype->order() == 1);

    Type transposedVector = TensorType::make(ttype->componentType,
                                             ttype->dimensions,
                                             !ttype->isColumnVector);

    const_cast<ExprNodeBase*>(to<ExprNodeBase>(vec))->type = transposedVector;
  }

  bool compare(const Type &l, const Type &r, ProgramContext *ctx) {
    if (l.kind() != r.kind()) {
      return false;
    }

//    if (l.isTensor()) {
//      if (l.toTensor()->isColumnVector != r.toTensor()->isColumnVector) {
//        return false;
//      }
//    }

    if (l != r) {
      return false;
    }
    return true;
  }

  #define CHECK_IS_TENSOR(expr, loc)                    \
    do {                                                \
      if (!expr.type().isTensor()) {                \
        std::stringstream errorStr;                     \
        errorStr << "expected tensor";                  \
        REPORT_ERROR(errorStr.str(), loc);              \
      }                                                 \
    } while (0)

  #define CHECK_TYPE_EQUALITY(t1, t2, loc)              \
    do {                                                \
      if (!compare(t1, t2, ctx)) {                      \
        REPORT_TYPE_MISSMATCH(t1, t2, loc);             \
      }                                                 \
    } while (0)


  #define BINARY_ELWISE_TYPE_CHECK(lt, rt, loc)   \
    do {                                          \
      iassert(lt.isTensor() && rt.isTensor());    \
      const TensorType *ltt = lt.toTensor();      \
      const TensorType *rtt = rt.toTensor();      \
      if (ltt->order() > 0 && rtt->order() > 0) { \
        CHECK_TYPE_EQUALITY(lt, rt, loc);         \
      }                                           \
    }                                             \
    while (0)
}

%union {
  int         num;
  double      fnum;
  const char *string;

  ir::Func *function;

  ir::Type                      *type;
  ir::Field                     *field;
  std::vector<ir::Field>        *fields;
  std::vector<ir::IndexSet>     *indexSets;
  ir::IndexSet                  *indexSet;

  ir::ScalarType                *scalarType;

  ir::Var                       *var;
  std::vector<ir::Var>          *vars;

  ir::Stmt                      *stmt;
  std::vector<ir::Stmt>         *stmts;
  ir::Expr                      *expr;
  std::vector<ir::Expr>         *exprs;
  ir::IRBuilder::BinaryOperator  binop;
  ir::ReductionOperator::Kind    reductionop;
  TensorValues<double>          *TensorDoubleValues;
  TensorValues<int>             *TensorIntValues;

  std::vector<std::string> *strings;
}
%destructor {} <num> <fnum> <binop> <reductionop>
%destructor { free((void*)($$)); } <string>
%destructor { delete $$; } <*>


// Tokens
%token UNKNOWN

// Literals
%token <num>    INT_LITERAL    "int literal"
%token <fnum>   FLOAT_LITERAL  "float literal"
%token <string> STRING_LITERAL "string literal"
%token <string> IDENT          "identifier"

// Precedence
%nonassoc    "\\"               // solve
%precedence  AND OR
%left        "==" "!="
%left        "<" ">" "<=" ">="
%left        "-" "+"
%left        "*" "/"
%precedence  NEG                // negation
%right       "^"                // exponentiation
%right       "'"                // transpose

// Keywords
%token INT       "int"
%token FLOAT     "float"
%token TENSOR    "tensor"
%token ELEMENT   "element"
%token SET       "set"
%token CONST     "const"
%token EXTERN    "extern"
%token PROC      "proc"
%token FUNC      "func"
%token INOUT     "inout"
%token MAP       "map"
%token TO        "to"
%token WITH      "with"
%token REDUCE    "reduce"
%token WHILE     "while"
%token IF        "if"
%token ELIF      "elif"
%token ELSE      "else"
%token FOR       "for"
%token IN        "in"
%token BLOCKEND  "end"
%token RETURN    "return"
%token TEST      "%!"
%token PRINT     "print"


%token RARROW    "->"
%token LP        "("
%token RP        ")"
%token LB        "["
%token RB        "]"
%token LC        "{"
%token RC        "}"
%token LA        "<"
%token RA        ">"
%token COMMA     ","
%token PERIOD    "."
%token COL       ":"
%token SEMICOL   ";"

%token ASSIGN    "="
%token PLUS      "+"
%token MINUS     "-"
%token STAR      "*"
%token SLASH     "/"
%token DOTSTAR   ".*"
%token DOTSLASH  "./"
%token EXP       "^"
%token TRANSPOSE "'"
%token BACKSLASH "\\"

%token EQ        "=="
%token NE        "!="
%token LE        "<="
%token GE        ">="
%token AND       "and"
%token OR        "or"
%token NOT       "not"
%token XOR       "xor"
%token TRUE      "true"
%token FALSE     "false"

%token END 0     "end of file"

// Rules
%start program
%%

program
  : /* empty */
  | program program_element

program_element
  : element_type_decl
  | procedure {
    Func func = convertAndDelete($procedure);
    std::string name = func.getName();
    if (ctx->containsFunction(name)) {
      REPORT_ERROR("procedure redefinition (" + name + ")", @procedure);
    }
    ctx->addFunction(func);
  }
  | function {
    Func func = convertAndDelete($function);
    std::string name = func.getName();
    if (ctx->containsFunction(name)) {
      REPORT_ERROR("function redefinition (" + name + ")", @function);
    }
    ctx->addFunction(func);
  }
  | extern
  | stmt
  | test

// Externs
%type <var> extern;
extern
  : "extern" argument_decl ";" {
    Var externVar = convertAndDelete($argument_decl);
    ctx->addExtern(externVar);
    ctx->addSymbol(externVar);
  }


// Element Definitions
%type <type> element_type_decl;
element_type_decl
  : "element" IDENT field_decl_list "end" {
    string name = convertAndFree($IDENT);
    unique_ptr<vector<Field>> fields($field_decl_list);

    if (ctx->containsElementType(name)) {
      REPORT_ERROR("struct redefinition (" + name + ")", @element_type_decl);
    }

    ctx->addElementType(ElementType::make(name, *fields));
  }

%type <fields> field_decl_list;
field_decl_list
  : /* empty */ {
    $$ = new vector<Field>;
  }
  | field_decl_list field_decl {
    $$ = $1;
    $$->push_back(*$field_decl);
    delete $field_decl;
  }

%type <field> field_decl;
field_decl
  : IDENT ":" tensor_type  ";" {
    std::string name = convertAndFree($IDENT);
    auto tensorType = convertAndDelete($tensor_type);
    $$ = new Field(name, tensorType);
  }


// Procedures and functions
%type <function> procedure;
procedure
  : {ctx->scope();} procedure_header stmt_block BLOCKEND {ctx->unscope();} {
    Func func = convertAndDelete($procedure_header);
    Stmt body = convertAndDelete($stmt_block);
    $$ = new Func(func.getName(), func.getArguments(), func.getResults(), body);
  }

%type <function> procedure_header;
procedure_header
  : "proc" IDENT {
    std::string name = convertAndFree($IDENT);
    auto arguments = vector<Var>();
    auto results = vector<Var>();

    for (auto &extPair : ctx->getExterns()) {
      Var ext = ctx->getExtern(extPair.first);

      // TODO: Make extResult a mutable parameter
      arguments.push_back(ext);
    }

    $$ = new Func(name, arguments, results, Stmt());
  }

%type <function> function;
function
  : {ctx->scope();} function_header stmt_block BLOCKEND {ctx->unscope();} {
    Func func = convertAndDelete($function_header);
    Stmt body = convertAndDelete($stmt_block);
    $$ = new Func(func.getName(), func.getArguments(), func.getResults(), body);
  }

%type <function> function_header;
function_header
  : "func" IDENT "(" arguments ")" results {
    std::string name = convertAndFree($IDENT);
    auto arguments = unique_ptr<vector<Var>>($arguments);
    auto results = unique_ptr<vector<Var>>($results);
    auto newArguments = unique_ptr<vector<Var>>(new vector<Var>());
    
    std::set<std::string> argNames;
    for (Var &arg : *arguments) {
      auto found = arg.getName().find("___inout___");
      if (found != string::npos) {
        // this is an inout param
        string newName = arg.getName().substr(0,found);
        auto newArg = Var(newName, arg.getType());
        ctx->addSymbol(newName, newArg, Symbol::ReadWrite);
        argNames.insert(newArg.getName());
        newArguments->push_back(newArg);
      } else {
        ctx->addSymbol(arg.getName(), arg, Symbol::Read);
        argNames.insert(arg.getName());
        newArguments->push_back(arg);
      }
    }

    $$ = new Func(name, *newArguments, *results, Stmt());

    for (Var &res : *results) {
      Symbol::Access access = (argNames.find(res.getName()) != argNames.end())
                              ? Symbol::ReadWrite : Symbol::ReadWrite;
      ctx->addSymbol(res.getName(), res, access);
    }
  }

%type <vars> arguments;
arguments
  : /* empty */ {
    $$ = new vector<Var>;
  }
  | argument_list {
    $$ = $1;
 }

%type <vars> argument_list;
argument_list
  : argument_decl {
    auto argument = convertAndDelete($argument_decl);
    $$ = new vector<Var>;
    $$->push_back(argument);
  }
  | argument_list "," argument_decl {
    auto argument = convertAndDelete($argument_decl);
    $$ = $1;
    $$->push_back(argument);
  }

%type <var> argument_decl;
argument_decl
  : INOUT IDENT ":" type {
    // this is by no means the best way to do this, but it works.
    std::string name = convertAndFree($IDENT).append("___inout___");

    auto type = convertAndDelete($type);
    $$ = new Var(name, type);
  }
  | IDENT ":" type {
    std::string name = convertAndFree($IDENT);

    auto type = convertAndDelete($type);
    $$ = new Var(name, type);
  }


%type <vars> results;
results
  : /* empty */ {
    $$ = new vector<Var>;
  }
  | RARROW "(" result_list ")" {
    $$ = $3;
  }

%type <vars> result_list;
result_list
  : result_decl {
    auto result = convertAndDelete($result_decl);
    $$ = new vector<Var>;
    $$->push_back(result);
  }
  | result_list "," result_decl {
    auto result = convertAndDelete($result_decl);
    $$ = $1;
    $$->push_back(result);
  }

%type <var> result_decl;
result_decl
  : IDENT ":" type {
    std::string name = convertAndFree($IDENT);
    auto type = convertAndDelete($type);
    $$ = new Var(name, type);
  }


// Statements
%type <stmt> stmt_block;
stmt_block
  : /* empty */ {
    $$ = new Stmt(Pass::make());
  }
  | stmts {
    vector<Stmt> stmts = *ctx->getStatements();
    if (stmts.size() == 0) {$$ = new Stmt(Pass::make()); break;} // TODO: remove
    $$ = new Stmt((stmts.size() == 1) ? stmts[0] : Block::make(stmts));
  }

stmts
  : stmt
  | stmts stmt

stmt
  : assign_stmt
  | map_stmt
  | field_write_stmt
  | tensor_write_stmt
  | if_stmt
  | while_stmt
  | for_stmt
  | const_stmt
  | expr_stmt
  | print_stmt

assign_stmt
  // This rule must use idents instead of IDENT or else the parser cannot parse
  // map statements...  This is too hacky and must be fixed.
  : idents "=" expr ";" {
    if ($expr == nullptr) {break;} // TODO: Remove check

    auto varNames = convertAndDelete($idents);
    Expr value = convertAndDelete($expr);

    if (varNames.size() > 1) {
      REPORT_ERROR("can only assign to one value in a non-map statement",
                   @idents);
    }
    string varName = varNames[0];

    Var var;
    if (ctx->hasSymbol(varName)) {
      Symbol symbol = ctx->getSymbol(varName);

      if (!symbol.isWritable()) {
        REPORT_ERROR(varName + " is not writable", @idents);
      }

      CHECK_TYPE_EQUALITY(symbol.getVar().getType(), value.type(), @expr);

      var = symbol.getVar();
    }
    else {
      var = Var(varName, value.type());
      ctx->addSymbol(varName, var, Symbol::ReadWrite);
    }

    // TODO: This should be dealt with inside the ident_expr rule
    if (isa<VarExpr>(value) && value.type().isTensor()) {
      // The statement assign a tensor to a tensor, so we change it to an
      // assignment index expr
      value = ctx->getBuilder()->unaryElwiseExpr(IRBuilder::None, value);
    }

    ctx->addStatement(AssignStmt::make(var, value));
  }

// Map Statement
map_stmt
  : idents "=" "map" IDENT[func] partial_expr_list "to" IDENT[target] with reduce {
    auto varNames = unique_ptr<vector<string>>($idents);

    auto partialExprList = unique_ptr<vector<Expr>>($partial_expr_list);
    
    string funcName = convertAndFree($func);
    string targetsName = convertAndFree($target);

    Expr neighbor = convertAndDelete($with);
    ReductionOperator reduction($reduce);

    if (!ctx->containsFunction(funcName)) {
      REPORT_ERROR("undefined function '" + funcName + "'", @func);
    }
    Func func = ctx->getFunction(funcName);

    if (varNames->size() != func.getResults().size()) {
      REPORT_ERROR("the number of variables (" + to_string(varNames->size()) +
                   ") does not match the number of results returned by " +
                   func.getName() + " (" + to_string(func.getResults().size()) +
                   ")", @1);
    }

    if (!ctx->hasSymbol(targetsName)) {
      REPORT_ERROR("undefined set '" + targetsName + "'", @target);
    }
    Expr targets = ctx->getSymbol(targetsName).getExpr();

    auto &results = func.getResults();
    vector<Var> vars;
    for (size_t i=0; i < results.size(); ++i) {
      string varName = (*varNames)[i];
      Var var;
      if (ctx->hasSymbol(varName)) {
        Symbol symbol = ctx->getSymbol(varName);

        if (!symbol.isWritable()) {
          REPORT_ERROR(varName + " is not writable", @1);
        }

        var = symbol.getVar();
      }
      else {
        var = Var(varName, results[i].getType());
        ctx->addSymbol(varName, var, Symbol::ReadWrite);
      }
      vars.push_back(var);
    }

    ctx->addStatement(Map::make(vars, func, *partialExprList, targets, neighbor,
      reduction));
  }

%type <exprs> partial_expr_list;
partial_expr_list
  : /* empty */ {
    $$ = new vector<Expr>();
  }
  | "(" expr_list_or_empty ")" {
    $$ = $2;
  }


%type <strings> idents;
idents
  : IDENT {
    $$ = new vector<string>;
    $$->push_back(convertAndFree($IDENT));
  }
  | idents "," IDENT {
    $$ = $1;
    $$->push_back(convertAndFree($IDENT));
  }

%type <expr> with;
with
  : /* empty */ {
    $$ = new Expr();
  }
  | "with" IDENT {
    std::string neighborsName = convertAndFree($IDENT);

    if (!ctx->hasSymbol(neighborsName)) {
      REPORT_ERROR("undefined set '" + neighborsName + "'", @2);
    }
    Expr neighbors = ctx->getSymbol(neighborsName).getExpr();

    $$ = new Expr(neighbors);
  }

%type <reductionop> reduce;
reduce
  : /* empty */ {
    $$ =  ReductionOperator::Undefined;
  }
  | "reduce" reduce_op {
    $$ =  $reduce_op;
  }

%type <reductionop> reduce_op;
reduce_op
  : "+" {
    $$ = ReductionOperator::Sum;
  }

field_write_stmt
  : IDENT "." IDENT "=" expr ";" {
    string setName = convertAndFree($1);
    string fieldName = convertAndFree($3);
    if ($expr == nullptr) break;  // TODO: remove check
    Expr value = convertAndDelete($expr);

    if (!ctx->hasSymbol(setName)) {
      REPORT_ERROR(setName + " is not defined in scope", @1);
    }

    const Symbol &setSymbol = ctx->getSymbol(setName);
    if (!setSymbol.isWritable()) {
      REPORT_ERROR(setName + " is not writable", @1);
    }

    Expr setExpr = setSymbol.getExpr();
    ctx->addStatement(FieldWrite::make(setExpr, fieldName, value));
  }

tensor_write_stmt
  : IDENT "(" expr_list ")" "=" expr ";" {
    std::string tensorName = convertAndFree($1);
    auto indices = unique_ptr<vector<Expr>>($expr_list);
    if ($expr == nullptr) break;  // TODO: remove check
    Expr value = convertAndDelete($expr);

    if(!ctx->hasSymbol(tensorName)) break;  // TODO: Remove check

    if (!ctx->hasSymbol(tensorName)) {
      REPORT_ERROR(tensorName + " is not defined in scope", @1);
    }

    const Symbol &tensorSymbol = ctx->getSymbol(tensorName);
    if (!tensorSymbol.isWritable()) {
      REPORT_ERROR(tensorName + " is not writable", @1);
    }

    Expr tensorExpr = tensorSymbol.getExpr();
    ctx->addStatement(TensorWrite::make(tensorExpr, *indices, value));
  }
  | IDENT "." IDENT[fieldName] "(" expr_list ")" "=" expr ";" {
    //TODO: This rule really should be:
    // field_read_expr "(" expr_list ")" "=" expr ";"
    // but this requires reworking a lot of the parser.
 
    string setName = convertAndFree($1);
    string fieldName = convertAndFree($3);
    auto indices = unique_ptr<vector<Expr>>($expr_list);
    if ($expr == nullptr) break;  // TODO: remove check
    Expr value = convertAndDelete($expr);

    if (!ctx->hasSymbol(setName)) {
      REPORT_ERROR(setName + " is not defined in scope", @1);
    }

    const Symbol &setSymbol = ctx->getSymbol(setName);
    if (!setSymbol.isWritable()) {
      REPORT_ERROR(setName + " is not writable", @1);
    }

    Expr setExpr = setSymbol.getExpr();

    Expr tensorExpr = FieldRead::make(setExpr, fieldName);
    ctx->addStatement(TensorWrite::make(tensorExpr, *indices, value));
  }

while_stmt
  : while_stmt_header while_body while_end {
    Expr cond = convertAndDelete($1);
    Stmt body = convertAndDelete($2);
    
    ctx->addStatement(While::make(cond, body));

  }

%type <expr> while_stmt_header;
while_stmt_header
  : "while" boolean_expr {
    ctx->scope();
    $$ = new Expr(convertAndDelete($2));
  }

%type <stmt> while_body;
while_body
  : stmt_block {

    $$ = new Stmt(convertAndDelete($1));
  }

while_end
  : BLOCKEND {
    ctx->unscope();
  }

%type <stmt> if_stmt;
if_stmt
  : "if" boolean_expr if_body else_clauses BLOCKEND {
    Expr cond = convertAndDelete($2);
    ctx->scope();
    Stmt trueStmt = convertAndDelete($3);
    ctx->unscope();
    Stmt elseStmt = convertAndDelete($4);
    Stmt *result = new Stmt(IfThenElse::make(cond, trueStmt, elseStmt));
    ctx->addStatement(*result);
    $$ = result;
  }

%type <stmt> if_body;
if_body
  : stmt_block {
    $$ = new Stmt(convertAndDelete($1));
  }

%type <stmt> else_clauses;
else_clauses
  : /* empty */ {
    $$ = new Stmt(Pass::make());
  }
  | "else" stmt_block {
    ctx->scope();
    $$ = new Stmt(convertAndDelete($2));
    ctx->unscope();
  }
  | "elif" boolean_expr if_body else_clauses {
    Expr cond = convertAndDelete($2);
    ctx->scope();
    Stmt trueStmt = convertAndDelete($3);
    ctx->unscope();
    Stmt elseStmt = convertAndDelete($4);
    Stmt *result = new Stmt(IfThenElse::make(cond, trueStmt, elseStmt));
    ctx->addStatement(*result);
    $$ = result;
  }

for_stmt
  : for_stmt_header index_set stmt_block for_stmt_footer{    
    if($2->getKind()==IndexSet::Set){
      ctx->addStatement(For::make(*$1,ForDomain(*$2), *$3));
    }
    delete $1;
    delete $2;
    delete $3;
  }
  | for_stmt_header expr ":" expr stmt_block for_stmt_footer {    
    ctx->addStatement(ForRange::make(*$1, *$2, *$4, *$5));
    delete $1;
    delete $2;
    delete $4;
    delete $5;
  }

%type <var> for_stmt_header;
for_stmt_header 
 : "for" IDENT "in" {
 string varName = convertAndFree($IDENT);
 Var * var = new Var(varName, Int);     
 ctx->scope();
 // If we need to write to loop variables, then that should be added as a
 // separate loop structure (that can't be vectorized easily)
 ctx->addSymbol(varName, *var, Symbol::Read);

 $$=var;
 }
  
for_stmt_footer
  : BLOCKEND {
    ctx->unscope();
  }

const_stmt
  : "const" IDENT ":" tensor_type "=" tensor_literal ";" {
    std::string name = convertAndFree($IDENT);
    auto type = convertAndDelete($tensor_type);
    const TensorType *tensorType = type.toTensor();

    Expr literalExpr = convertAndDelete($tensor_literal);

    iassert(literalExpr.type().isTensor())
        << "Only tensor literals are currently supported";
    auto litType = literalExpr.type();

    // If tensor_type is a 1xn matrix and $tensor_literal is a vector then we
    // cast $tensor_literal to a 1xn matrix.
    const TensorType *litTensorType = litType.toTensor();
    if (tensorType->order() == 2 && litTensorType->order() == 1) {
      const_cast<Literal*>(to<Literal>(literalExpr))->cast(type);
    }

    // Typecheck: value and literal types must be equivalent.
    CHECK_TYPE_EQUALITY(type, literalExpr.type(), @2);

    Var var(name, type);
    ctx->addConstant(var, literalExpr);
    ctx->addSymbol(var);
  }

%type <stmt> expr_stmt;
expr_stmt
  : expr ";" {
    $$ = NULL;
  }
  | ";" {
    $$ = NULL;
  }

print_stmt
  : "print" expr ";" {
     Expr expr = Expr(convertAndDelete($2));
     ctx->addStatement(Stmt(Print::make(expr)));
  }

// Expressions
%type <expr> expr;
expr
  : ident_expr
  | paren_expr
  | literal_expr
  | linear_algebra_expr
  | boolean_expr
  | field_read_expr
  | call_or_paren_read_expr


// Read Ident Expression
%type <expr> ident_expr;
ident_expr
  : IDENT {
    string ident = convertAndFree($IDENT);

    if (!ctx->hasSymbol(ident)) {
      REPORT_ERROR(ident + " is not defined in scope", @1);
    }

    const Symbol &symbol = ctx->getSymbol(ident);
    if (!symbol.isReadable()) {
      REPORT_ERROR(ident + " is not readable", @1);
    }

    Expr expr = symbol.getExpr();
    $$ = new Expr(expr);
  }


// Parenthesis Expression
%type <expr> paren_expr;
paren_expr
  : "(" expr ")" {
    if ($2 == NULL) { $$ = NULL; break; } // TODO: Remove check
    $$ = $2;
  }


// Linear Algebra Expressions
%type <expr> linear_algebra_expr;
linear_algebra_expr
  : "-" expr %prec NEG {
    if ($2 == NULL) { $$ = NULL; break; } // TODO: Remove check

    Expr expr = convertAndDelete($2);
    CHECK_IS_TENSOR(expr, @2);

    $$ = new Expr(ctx->getBuilder()->unaryElwiseExpr(IRBuilder::Neg, expr));
  }
  | expr elwise_binary_op expr {  // + - .* ./
    if ($1 == NULL || $3 == NULL) { $$ = NULL; break; } // TODO: Remove check

    Expr l = convertAndDelete($1);
    Expr r = convertAndDelete($3);

    CHECK_IS_TENSOR(l, @1);
    CHECK_IS_TENSOR(r, @3);

    const TensorType *ltype = l.type().toTensor();
    const TensorType *rtype = r.type().toTensor();

    if (ltype->order()>0&&rtype->order()>0 && !compare(l.type(),r.type(),ctx)) {
        REPORT_TYPE_MISSMATCH(l.type(), r.type(), @2);
    }

    BINARY_ELWISE_TYPE_CHECK(l.type(), r.type(), @2);
    $$ = new Expr(ctx->getBuilder()->binaryElwiseExpr(l, $2, r));
  }
  | expr "*" expr {
    iassert($1 && $3);
    IRBuilder *builder = ctx->getBuilder();

    Expr l = convertAndDelete($1);
    Expr r = convertAndDelete($3);

    CHECK_IS_TENSOR(l, @1);
    CHECK_IS_TENSOR(r, @3);

    const TensorType *ltype = l.type().toTensor();
    const TensorType *rtype = r.type().toTensor();

    // Scale
    if (ltype->order()==0 || rtype->order()==0) {
      $$ = new Expr(builder->binaryElwiseExpr(l, IRBuilder::Mul, r));
    }
    // Vector-Vector Multiplication (inner and outer product)
    else if (ltype->order() == 1 && rtype->order() == 1) {
      // Inner product
      if (!ltype->isColumnVector) {
        if (!rtype->isColumnVector) {
          REPORT_ERROR("cannot multiply two row vectors", @2);
        }
        if (l.type() != r.type()) {
          REPORT_TYPE_MISSMATCH(l.type(), r.type(), @2);
        }
        $$ = new Expr(builder->innerProduct(l, r));
      }
      // Outer product (l is a column vector)
      else {
        if (rtype->isColumnVector) {
          REPORT_ERROR("cannot multiply two column vectors", @2);
        }
        if (l.type() != r.type()) {
          REPORT_TYPE_MISSMATCH(l.type(), r.type(), @2);
        }
        $$ = new Expr(builder->outerProduct(l, r));
      }
    }
    // Matrix-Vector
    else if (ltype->order() == 2 && rtype->order() == 1) {
      // TODO: Figure out how column vectors should be handled here
      if (ltype->dimensions[1] != rtype->dimensions[0]){
        REPORT_TYPE_MISSMATCH(l.type(), r.type(), @2);
      }
      $$ = new Expr(builder->gemv(l, r));
    }
    // Vector-Matrix
    else if (ltype->order() == 1 && rtype->order() == 2) {
      // TODO: Figure out how column vectors should be handled here
      if (ltype->dimensions[0] != rtype->dimensions[0]) {
        REPORT_TYPE_MISSMATCH(l.type(), r.type(), @2);
      }
      $$ = new Expr(builder->gevm(l,r));
    }
    // Matrix-Matrix
    else if (ltype->order() == 2 && rtype->order() == 2) {
      if (ltype->dimensions[1] != rtype->dimensions[0]){
        REPORT_TYPE_MISSMATCH(l.type(), r.type(), @2);
      }
      $$ = new Expr(builder->gemm(l,r));
    }
    else {
      REPORT_ERROR("cannot multiply >2-order tensors using *", @2);
      $$ = NULL;
    }
  }
  | expr "/" expr {
    iassert($1 && $3);
    IRBuilder *builder = ctx->getBuilder();

    Expr l = convertAndDelete($1);
    Expr r = convertAndDelete($3);

    CHECK_IS_TENSOR(l, @1);
    CHECK_IS_TENSOR(r, @3);

    const TensorType *ltype = l.type().toTensor();
    const TensorType *rtype = r.type().toTensor();

    if (ltype->order()==0 || rtype->order()==0) {
      $$ = new Expr(builder->binaryElwiseExpr(l, IRBuilder::Div, r));
    }
    else {
      REPORT_ERROR("division not supported for these tensor types" , @1);
    }
  }
  | expr "'" {
    if ($1 == NULL) { $$ = NULL; break; } // TODO: Remove check
    IRBuilder *builder = ctx->getBuilder();
    Expr expr = convertAndDelete($1);

    CHECK_IS_TENSOR(expr, @1);

    const TensorType *type = expr.type().toTensor();
    switch (type->order()) {
      case 0:
        // OPT: This might lead to redundant code to be removed in later pass
        $$ = new Expr(builder->unaryElwiseExpr(IRBuilder::None, expr));
        break;
      case 1:
        // OPT: This might lead to redundant code to be removed in later pass
        $$ = new Expr(builder->unaryElwiseExpr(IRBuilder::None, expr));
        if (!type->isColumnVector) {
          transposeVector(*$$);
        }
        break;
      case 2:
        $$ = new Expr(builder->transposedMatrix(expr));
        break;
      default:
        REPORT_ERROR("cannot transpose >2-order tensors using '", @1);
        $$ = NULL;
    }
  }
  | expr "^" expr {
    $$ = NULL;
    delete $1;
    delete $3;
  }
  | expr "\\" expr {  // Solve
    if ($1 == NULL || $3 == NULL) { $$ = NULL; break; } // TODO: Remove check
    $$ = NULL;
    delete $1;
    delete $3;
  }

%type <binop> elwise_binary_op;
elwise_binary_op
  : "+"  { $$ = IRBuilder::Add; }
  | "-"  { $$ = IRBuilder::Sub; }
  | ".*" { $$ = IRBuilder::Mul; }
  | "./" { $$ = IRBuilder::Div; }


// Boolean Expressions
%type <expr> boolean_expr;
boolean_expr
  : "(" boolean_expr ")" {
    if ($2 == NULL) { $$ = NULL; break; } // TODO: Remove check
    $$ = $2;
  }
  | expr "==" expr {
    if ($1 == NULL || $3 == NULL) { $$ = NULL; break; } // TODO: Remove check
    Expr l = convertAndDelete($1);
    Expr r = convertAndDelete($3);
    $$ = new Expr(Eq::make(l, r));
  }
  | expr "!=" expr {
    if ($1 == NULL || $3 == NULL) { $$ = NULL; break; } // TODO: Remove check
    Expr l = convertAndDelete($1);
    Expr r = convertAndDelete($3);
    $$ = new Expr(Ne::make(l, r));
  }
  | expr ">" expr {
    if ($1 == NULL || $3 == NULL) { $$ = NULL; break; } // TODO: Remove check
    Expr l = convertAndDelete($1);
    Expr r = convertAndDelete($3);
    $$ = new Expr(Gt::make(l, r));
  }
  | expr "<" expr {
    if ($1 == NULL || $3 == NULL) { $$ = NULL; break; } // TODO: Remove check
    Expr l = convertAndDelete($1);
    Expr r = convertAndDelete($3);
    $$ = new Expr(Lt::make(l, r));
  }
  | expr ">=" expr {
    if ($1 == NULL || $3 == NULL) { $$ = NULL; break; } // TODO: Remove check
    Expr l = convertAndDelete($1);
    Expr r = convertAndDelete($3);
    $$ = new Expr(Ge::make(l, r));
  }
  | expr "<=" expr {
    if ($1 == NULL || $3 == NULL) { $$ = NULL; break; } // TODO: Remove check
    Expr l = convertAndDelete($1);
    Expr r = convertAndDelete($3);
    $$ = new Expr(Le::make(l, r));
  }
  | expr "and" expr {
    if ($1 == NULL || $3 == NULL) { $$ = NULL; break; } // TODO: Remove check
    Expr l = convertAndDelete($1);
    Expr r = convertAndDelete($3);
    $$ = new Expr(And::make(l, r));
  }
  | expr "or" expr {
    if ($1 == NULL || $3 == NULL) { $$ = NULL; break; } // TODO: Remove check
    Expr l = convertAndDelete($1);
    Expr r = convertAndDelete($3);
    $$ = new Expr(Or::make(l, r));
  }
  | "not" expr {
    if ($2 == NULL) { $$ = NULL; break; } // TODO: Remove check
    Expr r = convertAndDelete($2);
    $$ = new Expr(Not::make(r));
  }
  | expr "xor" expr {
    if ($1 == NULL || $3 == NULL) { $$ = NULL; break; } // TODO: Remove check
    Expr l = convertAndDelete($1);
    Expr r = convertAndDelete($3);
    $$ = new Expr(Xor::make(l, r));
  }
  | "true" {
    bool val = true;
    $$ = new Expr(Literal::make(val));
  }
  | "false" {
    bool val = false;
    $$ = new Expr(Literal::make(val));
  }

// Field Read Expressions
%type <expr> field_read_expr;
field_read_expr
  : set_read_expr "." IDENT[fieldName] {
    iassert($set_read_expr);
    iassert($set_read_expr->type().defined());

    Expr elemOrSet = convertAndDelete($set_read_expr);
    std::string fieldName = convertAndFree($fieldName);

    Type type = elemOrSet.type();
    if (!(type.isElement() || type.isSet())) {
      std::stringstream errorStr;
      errorStr << "only elements and sets have fields";
      REPORT_ERROR(errorStr.str(), @1);
    }

    const ElementType *elemType = nullptr;
    if (elemOrSet.type().isElement()) {
      elemType = elemOrSet.type().toElement();
    }
    else if (elemOrSet.type().isSet()) {
      const SetType *setType = elemOrSet.type().toSet();
      elemType = setType->elementType.toElement();
    }
    iassert(elemType);

    if (!elemType->hasField(fieldName)) {
      REPORT_ERROR("undefined field '" + toString(elemOrSet)+"."+fieldName+ "'",
                   @fieldName);
    }

    $$ = new Expr(FieldRead::make(elemOrSet, fieldName));
  }

%type <expr> set_read_expr;
set_read_expr
  : ident_expr
  | paren_expr
  | call_or_paren_read_expr


// Call and Tensor Read Expressions
%type <expr> call_or_paren_read_expr;
call_or_paren_read_expr
  : IDENT "(" expr_list_or_empty ")" {
    std::string name = convertAndFree($IDENT);
    auto indices = unique_ptr<vector<Expr>>($expr_list_or_empty);

    if (ctx->hasSymbol(name)) {
      const Symbol &symbol = ctx->getSymbol(name);
      if (!symbol.isReadable()) {
        REPORT_ERROR(name + " is not readable", @1);
      }

      // The parenthesis read can read from a tensor or a tuple.
      auto expr = symbol.getExpr();
      if (expr.type().isTensor()) {
        $$ = new Expr(TensorRead::make(expr, *indices));
      }
      else if (expr.type().isTuple()) {
        if (indices->size() != 1) {
          REPORT_ERROR("reading a tuple requires exactly one index", @3);
        }
        $$ = new Expr(TupleRead::make(expr, (*indices)[0]));
      }
      else {
        REPORT_ERROR("can only access components in tensors and tuples", @1);
      }
    }
    else if (ctx->containsFunction(name)) {
      Func func = ctx->getFunction(name);
      $$ = new Expr(Call::make(func, *indices));
    }
    else {
      REPORT_ERROR(name + " is not defined in scope", @1);
    }
  }
  | field_read_expr "(" expr_list_or_empty ")" {
    $$ = NULL;
  }

%type <expr> call_expr;
call_expr
  : IDENT "(" expr_list_or_empty ")" {
    std::string funcName = convertAndFree($1);
    auto actuals = unique_ptr<vector<Expr>>($expr_list_or_empty);

    if (!ctx->containsFunction(funcName)) {$$ = NULL; break;} // TODO: Remove check

    if (!ctx->containsFunction(funcName)) {
      REPORT_ERROR("undefined function '" + funcName + "'", @1);
    }
    Func func = ctx->getFunction(funcName);

    $$ = new Expr(Call::make(func, *actuals));
  }

%type <exprs> expr_list_or_empty;
expr_list_or_empty
  : /* empty */ {
    $$ = new vector<Expr>();
  }
  | expr_list {
    $$ = $expr_list;
  }

%type <exprs> expr_list;
expr_list
  : expr {
    $$ = new std::vector<Expr>();
    if ($expr == NULL) break;  // TODO: Remove check
    $$->push_back(*$expr);
    delete $expr;
  }
  | expr_list "," expr {
    $$ = $1;
    if ($expr == NULL) break;  // TODO: Remove check
    $$->push_back(*$expr);
    delete $expr;
  }


// Types
%type <type> type;
type
  : element_type
  | set_type
  | tuple_type
  | tensor_type

%type <type> element_type;
element_type
  : IDENT {
    std::string name = convertAndFree($IDENT);

    if (!ctx->containsElementType(name)) {
      REPORT_ERROR("undefined element type '" + name + "'" , @1);
    }

    $$ = new Type(ctx->getElementType(name));
  }

%type <type> set_type;
set_type
  : "set" "{" element_type "}" {
    auto elementType = convertAndDelete($element_type);
    $$ = new Type(SetType::make(elementType, {}));
  }
  | "set" "{" element_type "}" "(" endpoints ")" {
    auto elementType = convertAndDelete($element_type);
    auto endpoints = convertAndDelete($endpoints);

    // TODO: Add endpoint information to set type
    $$ = new Type(SetType::make(elementType, endpoints));
  }

%type <exprs> endpoints;
endpoints
  : IDENT {
    $$ = new vector<Expr>;
    std::string name = convertAndFree($IDENT);

    if (!ctx->hasSymbol(name)) {
      REPORT_ERROR("undefined set type '" + name + "'" , @1);
    }
    $$->push_back(ctx->getSymbol(name).getExpr());
  }
  | endpoints "," IDENT {
    $$ = $1;
    std::string name = convertAndFree($IDENT);

    if (!ctx->hasSymbol(name)) {
      REPORT_ERROR("undefined set type '" + name + "'" , @1);
    }
    $$->push_back(ctx->getSymbol(name).getExpr());
  }

%type <type> tuple_type;
tuple_type
  : "(" element_type "*" INT_LITERAL ")" {
    auto elementType = convertAndDelete($element_type);

    if ($INT_LITERAL<1) {
      REPORT_ERROR("Must be 1 or greater", @3);
    }

    $$ = new Type(TupleType::make(elementType, $INT_LITERAL));
  }

%type <type> tensor_type;
tensor_type
  : component_type {
    auto componentType = convertAndDelete($component_type);
    $$ = new Type(TensorType::make(componentType));
  }
  | "tensor" "(" tensor_type[block_type] ")" {
    $$ = $block_type;
  }
  | "tensor" "[" index_sets "]" "(" tensor_type[block_type] ")" {
    auto blockTypePtr = convertAndDelete($block_type);
    const TensorType *blockType = blockTypePtr.toTensor();

    auto componentType = blockType->componentType;

    auto outerDimensions = unique_ptr<vector<IndexSet>>($index_sets);
    auto blockDimensions = blockType->dimensions;

    vector<IndexDomain> dimensions;
    if (blockType->order() == 0) {
      for (size_t i=0; i<outerDimensions->size(); ++i) {
        dimensions.push_back(IndexDomain((*outerDimensions)[i]));
      }
    }
    else {
      // TODO: Handle the following cases where there there are more inner than
      //       outer dimensions (e.g. a vector of matrixes) and where there are
      //       more outer than inner dimensions (e.g. a matrix of vectors)
      //       gracefully by padding with '1'-dimensions.
      // TODO: Handle case where there are more block than outer dimensions
      // TODO: Handle case where there are more outer than block dimensions
      // TODO: Remove below error
//      if (blockType->order() != outerDimensions->size()) {
//        REPORT_ERROR("Blocktype order (" + to_string(blockType->order()) +
//                     ") differ from number of dimensions", @index_sets);
//      }

//      iassert(blockDimensions.size() == outerDimensions->size());
      for (size_t i=0; i < outerDimensions->size(); ++i) {
        vector<IndexSet> dimension;
        dimension.push_back((*outerDimensions)[i]);
        dimension.insert(dimension.end(),
                         blockDimensions[i].getIndexSets().begin(),
                         blockDimensions[i].getIndexSets().end());

        dimensions.push_back(IndexDomain(dimension));
      }
    }

    $$ = new Type(TensorType::make(componentType, dimensions));
  }
  | tensor_type "'" {
    auto type = convertAndDelete($1);
    const TensorType *tensorType = type.toTensor();
    auto dimensions = tensorType->dimensions;
    auto componentType = tensorType->componentType;
    $$ = new Type(TensorType::make(componentType, dimensions, true));
  }

%type <indexSets> index_sets;
index_sets
  : index_set {
    $$ = new std::vector<IndexSet>();
    $$->push_back(*$index_set);
    delete $index_set;
  }
  | index_sets "," index_set {
    $$ = $1;
    $$->push_back(*$index_set);
    delete $index_set;
  }

%type <indexSet> index_set;
index_set
  : INT_LITERAL {
    $$ = new IndexSet($INT_LITERAL);
  }
  | IDENT {
    std::string setName = convertAndFree($IDENT);

    if (!ctx->hasSymbol(setName)) {
      REPORT_ERROR("the set has not been declared", @1);
    }

    Expr set = ctx->getSymbol(setName).getExpr();
    if (!set.type().isSet()) {
      REPORT_ERROR("an index set must be a set, a range or dynamic (*)", @1);
    }

    $$ = new IndexSet(set);
  }
  | "*" {
    $$ = new IndexSet();
  }

%type <scalarType> component_type;
component_type
  : INT {
    $$ = new ScalarType(ScalarType::Int);
  }
  | FLOAT {
    $$ = new ScalarType(ScalarType::Float);
  }


// Literals
%code requires {
  namespace {
    template <typename T>
    class TensorValues {
     public:
      TensorValues() : dimSizes(1) {};

      void addValue(const T &val) {
        values.push_back(val);
        dimSizes[dimSizes.size()-1]++;
      }
      void addDimension() { dimSizes.push_back(1); }

      bool dimensionsMatch(const TensorValues<T> &other, std::string *errors) {
        iassert(errors != NULL);
        std::string mismatchError = "missmatched dimension sizes";
        if (dimSizes.size()-1 != other.dimSizes.size()) {
          *errors = mismatchError;
          return false;
        }

        for (unsigned int i=0; i<dimSizes.size()-1; ++i) {
          if (dimSizes[i] != other.dimSizes[i]) {
            *errors = mismatchError;
            return false;
          }
        }
        return true;
      }

      void merge(const TensorValues<T> &other) {
        values.insert(values.end(), other.values.begin(), other.values.end());
        dimSizes[dimSizes.size()-1]++;
      }

      std::vector<unsigned int> dimSizes;
      std::vector<T>            values;
    };
  }
};


%type <expr> literal_expr;
literal_expr
  : tensor_literal

%type <expr> tensor_literal;
tensor_literal
  : dense_tensor_literal
  | dense_tensor_literal "'" {
    $$ = $1;
    transposeVector(*$$);
  }
  | scalar_literal

%type <expr> dense_tensor_literal;
dense_tensor_literal
  : "[" float_dense_tensor_literal "]" {
    auto values = unique_ptr<TensorValues<double>>($2);
    auto idoms = std::vector<IndexDomain>(values->dimSizes.rbegin(),
                                          values->dimSizes.rend());
    Type type = TensorType::make(ScalarType(ScalarType::Float), idoms);
    $$ = new Expr(Literal::make(type, values->values));
  }
  | "[" int_dense_tensor_literal "]" {
    auto values = unique_ptr<TensorValues<int>>($2);
    auto idoms = std::vector<IndexDomain>(values->dimSizes.rbegin(),
                                          values->dimSizes.rend());
    Type type = TensorType::make(ScalarType(ScalarType::Int), idoms);
    $$ = new Expr(Literal::make(type, values->values.data()));
  }


%type <TensorDoubleValues> float_dense_tensor_literal;
float_dense_tensor_literal
  : float_dense_matrix_literal {
    // If the matrix has only one column then we discard that dimension and
    // treat it as a vector.
    if ($1->dimSizes[$1->dimSizes.size()-1] == 1) {
      $1->dimSizes.pop_back();
    }
  }
  | float_dense_ndtensor_literal

%type <TensorDoubleValues> float_dense_ndtensor_literal;
float_dense_ndtensor_literal
  : "[" float_dense_matrix_literal "]" {
    $$ = $2;
    $$->addDimension();
  }
  | float_dense_ndtensor_literal "," "[" float_dense_matrix_literal "]" {
    auto  left = unique_ptr<TensorValues<double>>($1);
    auto right = unique_ptr<TensorValues<double>>($4);

    string errorStr;
    if(!left->dimensionsMatch(*right, &errorStr)) {
      REPORT_ERROR(errorStr, @2);
    }
    left->merge(*right);
    $$ = left.release();
  }

%type <TensorDoubleValues> float_dense_matrix_literal;
float_dense_matrix_literal
  : float_dense_vector_literal {
    $$ = $1;
    $$->addDimension();
  }
  | float_dense_matrix_literal ";" float_dense_vector_literal {
    auto  left = unique_ptr<TensorValues<double>>($1);
    auto right = unique_ptr<TensorValues<double>>($3);

    string errorStr;
    if(!left->dimensionsMatch(*right, &errorStr)) {
      REPORT_ERROR(errorStr, @2);
    }

    left->merge(*right);
    $$ = left.release();
  }

%type <TensorDoubleValues> float_dense_vector_literal;
float_dense_vector_literal
  : signed_float_literal {
    $$ = new TensorValues<double>();
    $$->addValue($1);
  }
  | float_dense_vector_literal "," signed_float_literal {
    $$ = $1;
    $$->addValue($3);
  }

%type <TensorIntValues> int_dense_tensor_literal;
int_dense_tensor_literal
  : int_dense_matrix_literal {
    // If the matrix has only one column then we discard that dimension and
    // treat it as a vector.
    if ($1->dimSizes[$1->dimSizes.size()-1] == 1) {
      $1->dimSizes.pop_back();
    }
  }
  | int_dense_ndtensor_literal

%type <TensorIntValues> int_dense_ndtensor_literal;
int_dense_ndtensor_literal
  : "[" int_dense_matrix_literal "]" {
    $$ = $2;
    $$->addDimension();
  }
  | int_dense_ndtensor_literal "," "[" int_dense_matrix_literal "]" {
    auto  left = unique_ptr<TensorValues<int>>($1);
    auto right = unique_ptr<TensorValues<int>>($4);

    string errorStr;
    if(!left->dimensionsMatch(*right, &errorStr)) {
      REPORT_ERROR(errorStr, @2);
    }
    left->merge(*right);
    $$ = left.release();
  }

%type <TensorIntValues> int_dense_matrix_literal;
int_dense_matrix_literal
  : int_dense_vector_literal {
    $$ = $1;
    $$->addDimension();
  }
  | int_dense_matrix_literal ";" int_dense_vector_literal {
    auto  left = unique_ptr<TensorValues<int>>($1);
    auto right = unique_ptr<TensorValues<int>>($3);

    string errorStr;
    if(!left->dimensionsMatch(*right, &errorStr)) {
      REPORT_ERROR(errorStr, @2);
    }

    left->merge(*right);
    $$ = left.release();
  }

%type <TensorIntValues> int_dense_vector_literal;
int_dense_vector_literal
  : signed_int_literal {
    $$ = new TensorValues<int>();
    $$->addValue($1);
  }
  | int_dense_vector_literal "," signed_int_literal {
    $$ = $1;
    $$->addValue($3);
  }

%type <expr> scalar_literal;
scalar_literal
  : signed_int_literal {
    $$ = new Expr(Literal::make($1));
  }
  | signed_float_literal {
    $$ = new Expr(Literal::make($1));
  }

%type <num> signed_int_literal;
signed_int_literal
  : INT_LITERAL {
    $$ = $INT_LITERAL;
  }
  | "-" INT_LITERAL {
    $$ = -$INT_LITERAL;
  }

%type <fnum> signed_float_literal;
signed_float_literal
  : FLOAT_LITERAL {
    $$ = $FLOAT_LITERAL;
  }
  | "-" FLOAT_LITERAL {
    $$ = -$FLOAT_LITERAL;
  }

// Tests
test
  // Test element literal functions
  : "%!" IDENT "(" expr_list_or_empty ")" "==" tensor_literal ";" {
    std::string name = convertAndFree($IDENT);
    auto actuals = unique_ptr<vector<Expr>>($expr_list_or_empty);
    auto expected = convertAndDelete($tensor_literal);

    std::vector<Expr> literalArgs;
    literalArgs.reserve(actuals->size());
    for (auto &arg : *actuals) {
      if (!isa<Literal>(arg)) {
        REPORT_ERROR("function calls in tests must have literal arguments", @1);
      }
      literalArgs.push_back(arg);
    }

    std::vector<Expr> expecteds;
    expecteds.push_back(expected);
    ctx->addTest(new FunctionTest(name, literalArgs, expecteds));
  }
  // Test systems (see github issue #66)
  | "%!" IDENT "=" system_generator ":" extern_assert {
    std::string setName = convertAndFree($IDENT);
    unique_ptr<System> system($system_generator);

    //std::map<std::string, simit::SetBase*> externs;
    //externs[setName] = system->elements;
    //ctx->addTest(new ProcedureTest("test", externs));
  }

%code requires {
  struct System {
    //simit::Set<> *elements = nullptr;
    //simit::Set<2> edges;
    //simit::Set<3> triangles; // connects three elements
    //simit::Set<3> faces;     // connects three edges
  };
};

%union {
  System *system;
};

%type <system> system_generator;
system_generator
  : IDENT
  | INT_LITERAL[numElems] {
    System *sys = new System;
    //sys->elements = new simit::Set<>;
    //createElements(sys->elements, $numElems);
    $$ = sys;
  }

extern_assert
  : IDENT[set] "." IDENT[field] "=" tensor_literal "->" tensor_literal

%%
