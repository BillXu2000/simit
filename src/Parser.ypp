%code top{
  #include <stdlib.h>
  #include <assert.h>
  #include <iostream>
  #include <algorithm>

  #include "Logger.h"
  #include "Frontend.h"
  #include "Util.h"
  #include "Errors.h"
  #include "Test.h"
  using namespace std;
  using namespace simit;

  #define REPORT_ERROR(msg, loc)                                        \
    do {                                                                \
      yyerror(&loc, symtable, errors, tests, std::string(msg).c_str()); \
      YYERROR;                                                          \
    } while (0)
}

%code requires {
  #include <vector>

  #include "IR.h"
  #include "Types.h"
}

%require "3.0"
%define parse.error verbose
%define parse.lac full
%locations
%pure-parser

%parse-param{simit::SymbolTable &symtable}
%parse-param{std::list<simit::Error> &errors}
%parse-param{std::list<simit::Test> &tests}

%union {
  // Primitive literals
  int          num;
  double      fnum;
  const char *string;

  // Values
  simit::Value  *Value;
  simit::Tensor *Tensor;
  simit::Store  *Store;

}
%destructor {} <num> <fnum> <ComponentType>
%destructor { free((void*)($$)); } <string>
%destructor { delete $$; } <*>

%code {
  #include "Scanner.h"
  void yyerror(YYLTYPE *loc, simit::SymbolTable &symtable,
               std::list<simit::Error> &errors, std::list<simit::Test>  &tests,
               const char *errorStr) {
    errors.push_back(Error(loc->first_line, loc->first_column,
                           loc->last_line, loc->last_column,
                           errorStr));
  }
}

%token UNKNOWN

// Literals
%right    "="
%nonassoc "\\"               // solve
%left     "==" "!="
%left     "<" ">" "<=" ">="
%left     "-" "+"
%left     "*" "/"
%left     NEG                // negation
%right    "^"                // exponentiation
%right    "'"                // transpose

%token <num>    INT_LITERAL    "int literal"
%token <fnum>   FLOAT_LITERAL  "float literal"
%token <string> STRING_LITERAL "string literal"
%token <string> IDENT          "identifier"

// Keywords
%token INT       "int"
%token FLOAT     "float"
%token STRUCT    "struct"
%token CONST     "const"
%token EXTERN    "extern"
%token PROC      "proc"
%token FUNC      "func"
%token TENSOR    "Tensor"
%token MAP       "map"
%token TO        "to"
%token WITH      "with"
%token REDUCE    "reduce"
%token WHILE     "while"
%token IF        "if"
%token ELIF      "elif"
%token ELSE      "else"
%token BLOCKEND  "end"
%token RETURN    "return"
%token TEST      "test"

%token RARROW    "->"
%token LP        "("
%token RP        ")"
%token LB        "["
%token RB        "]"
%token LC        "{"
%token RC        "}"
%token LA        "<"
%token RA        ">"
%token COMMA     ","
%token PERIOD    "."
%token COL       ":"
%token SEMICOL   ";"

%token ASSIGN    "="
%token PLUS      "+"
%token MINUS     "-"
%token STAR      "*"
%token SLASH     "/"
%token EXP       "^"
%token TRANSPOSE "'"
%token BACKSLASH "\\"

%token EQ        "=="
%token NE        "!="
%token LE        "<="
%token GE        ">="

// End of file
%token END 0 "end of file"


%start program
%%
program
  : /* empty */
  | program program_element

program_element
  : struct
  | procedure
  | function
  | stmt
  | extern
  | test

// Externs
extern
  : "extern" IDENT type "{" "}" ";" {
    free((void*)$IDENT);
    delete $type;
  }
  | "extern" IDENT type "[" endpoints "]" "{" "}" ";" {
    free((void*)$IDENT);
    delete $type;
  }

endpoints
  : IDENT {
    free((void*)$IDENT);
  }
  | endpoints "," IDENT {
    free((void*)$IDENT);
  }


// Structs
struct
  : "struct" IDENT struct_decl_block {
    free((void*)$IDENT);
  }

struct_decl_block
  : /* empty */
  | struct_decl_list BLOCKEND

struct_decl_list
  : /* empty */
  | field_decl struct_decl_list

field_decl
  : var_decl  ";"


// Procedures and functions
procedure
  : PROC IDENT stmt_block BLOCKEND {
    free((void*)$IDENT);
  }

function
  : function_header stmt_block BLOCKEND

function_header
  : FUNC IDENT "(" params ")" results {
    free((void*)$IDENT);
  }

params
 : /* empty */
 | param_list

results
  : /* empty */
  | RARROW "(" param_list ")"

param_list
  : var_decl
  | param_list "," var_decl


// Statements
stmt_block
  : /* empty */
  | stmt_block stmt

stmt
  : const_stmt
  | if_stmt
  | return_stmt
  | assign_stmt
  | expr_stmt

const_stmt
  : "const" IDENT ":" tensor_type "=" tensor_literal ";" {
    $tensor_literal->setName($IDENT);
    free((void*)$IDENT);
    auto tensorType = unique_ptr<TensorType>($tensor_type);
    auto tensorLiteral = unique_ptr<LiteralTensor>($tensor_literal);

    // If $type is a 1xn matrix and $tensor_literal is a vector then we cast
    // $tensor_literal to a 1xn matrix.
    if (tensorType->getOrder() == 2 && tensorLiteral->getOrder() == 1) {
      tensorLiteral->cast(tensorType.release());
    }

    // Typecheck: value and literal types must be equivalent.
    //            Note that the use of $tensor_type is deliberate as tensorType
    //            can have been released.
    if (*$tensor_type != *(tensorLiteral->getType())) {
      REPORT_ERROR("error, value type does not match literal type", @5);
    }

    symtable.addNode(tensorLiteral.release());
  }
  | "const" IDENT ":" element_type "=" element_literal ";" {
    free((void*)$IDENT);
    delete $element_type;
  }

if_stmt
  : "if" expr stmt_block else_clauses BLOCKEND

else_clauses
  : /* empty */
  | elif_clauses "else" stmt_block

elif_clauses
  : /* empty */
  | elif_clauses "elif" expr stmt_block

return_stmt
  : "return" ";"

assign_stmt
  : lhs_expr_list "=" expr_list ";"

expr_stmt
  : ";"
  | expr ";"


// Expressions
%type<Tensor> expr;
%destructor {} <Tensor>;  // TODO: Remove this line

expr
  : IDENT {
    string ident($IDENT);
    free((void*)$IDENT);

    IRNode *node = symtable[ident];
    if (node == NULL) {
      // TODO: Re-introduce this code once functions and parameters work
      // REPORT_ERROR("error, " + ident + " is not defined in scope", @1);
      YYACCEPT;
    }

    Tensor *tensor = dynamic_cast<Tensor*>(node);
    if (tensor == NULL) {
      REPORT_ERROR("error, " + ident + " is not a tensor", @1);
    }

    $$ = tensor;
  }
  | FLOAT_LITERAL
  | INT_LITERAL
  | STRING_LITERAL

  | expr "\\" expr
  | expr "+" expr
  | expr "-" expr
  | expr "*" expr
  | expr "/" expr
  |      "-" expr  %prec NEG {

  }
  | expr "'"
  | expr "^" expr
  | expr "==" expr
  | expr "!=" expr
  | expr "<"  expr
  | expr ">"  expr
  | expr "<=" expr
  | expr ">=" expr
  | "(" expr ")"
  | expr ":" expr
  | call_expr
  | expr "." expr
  | index_expr
  | map_expr

call_expr
  : expr "(" ")"
  | expr "(" expr_list ")"

expr_list
  : expr
  | expr_list "," expr


// Map expressions
map_expr
  : "map" IDENT[target] "to" IDENT[neighbor] with reduce {
    free((void*)$target);
    free((void*)$neighbor);
  }

with
  : /* empty */
  | "with" IDENT {
    free((void*)$IDENT);
  }

reduce
  : /* empty */
  | "reduce" reduction_op


// Index expressions
index_expr
  : reduction_indices expr

reduction_indices
  : /* empty */
  | reduction_indices reduction_index

reduction_index
  : reduction_op IDENT {
    free((void*)$IDENT);
  }
  | reduction_op "{" IDENT "}" {
    free((void*)$IDENT);
  }
  | IDENT[rfunc] "{" IDENT[rval] "}" {
    free((void*)$rfunc);
    free((void*)$rval);
  }

reduction_op
  : "+"
  | "-"


// Lhs expressions
lhs_expr
  : IDENT {
    string ident($IDENT);
    free((void*)$IDENT);
  }
  | IDENT "(" expr_list ")"
  | IDENT "." IDENT

lhs_expr_list
  : lhs_expr
  | lhs_expr_list "," lhs_expr


// Variables
var_decl
  : IDENT ":" type {
    delete $type;
    free((void*)$IDENT);
  }


// Types
%union {
  simit::Type                      *Type;
  simit::ElementType               *ElementType;
  simit::TensorType                *TensorType;
  simit::TensorType::ComponentType  ComponentType;
  std::vector<simit::Shape*>       *Shapes;
  simit::Shape                     *Shape;
  std::vector<simit::Dimension*>   *Dimensions;
  simit::Dimension                 *Dimension;
};

%type <Type>           type;
%type <ElementType>    element_type;
%type <TensorType>     tensor_type;
%type <Shapes>         shapes;
%type <Shape>          shape;
%type <Dimensions>     dimensions;
%type <Dimension>      dimension;
%type <ComponentType>  component_type;

type
  : element_type {
    $$ = $element_type;
  }
  | tensor_type {
    $$ = $tensor_type;
  }

element_type
  : IDENT {
    $$ = new ElementType();
    free((void*)$IDENT);
  }

tensor_type
  : component_type {
    $$ = new ScalarType($component_type);
  }
  | TENSOR shapes "(" component_type ")" {
    auto shapes = unique_ptr<vector<Shape*>>($shapes);

    $$ = new ScalarType($component_type);
    typedef vector<Shape*>::reverse_iterator shapes_rit_t;
    for (shapes_rit_t rit = $shapes->rbegin(); rit != $shapes->rend(); ++rit) {
      $$ = new NDTensorType(*rit, $$);
    }
  }

shapes
  : /* empty */ {
    $$ = new vector<Shape*>();
  }
  | shapes shape {
    $$ = $1;
    $$->push_back($shape);
  }

shape
  : "[" dimensions "]" {
    $$ = new Shape(*$dimensions);
    delete $dimensions;
  }

dimensions
  : dimension {
    $$ = new vector<Dimension*>();
    $$->push_back($dimension);
  }
  | dimensions "," dimension {
    $$ = $1;
    $$->push_back($dimension);
  }

dimension
  : INT_LITERAL {
    $$ = new Dimension($INT_LITERAL);
  }
  | IDENT {
    free((void*)$IDENT);
    $$ = new Dimension(123456789);  // TODO: This needs to be a set dimension
  }
  | "*" {
    $$ = new Dimension();
  }

component_type
  : INT {
    $$ = ScalarType::INT;
  }
  | FLOAT {
    $$ = ScalarType::FLOAT;
  }


// Literals
%code requires {
  #include <assert.h>
  namespace {
    template <typename T>
    class TensorValues {
     public:
      TensorValues() : dimSizes(1) {};

      void addValue(const T &val) {
        values.push_back(val);
        dimSizes[dimSizes.size()-1]++;
      }
      void addDimension() { dimSizes.push_back(1); }

      bool dimensionsMatch(const TensorValues<T> &other, std::string *errors) {
        assert(errors != NULL);
        std::string mismatchError = "error, missmatched dimension sizes";
        if (dimSizes.size()-1 != other.dimSizes.size()) {
          *errors = mismatchError;
          return false;
        }

        for (unsigned int i=0; i<dimSizes.size()-1; ++i) {
          if (dimSizes[i] != other.dimSizes[i]) {
            *errors = mismatchError;
            return false;
          }
        }
        return true;
      }

      void merge(const TensorValues<T> &other) {
        values.insert(values.end(), other.values.begin(), other.values.end());
        dimSizes[dimSizes.size()-1]++;
      }

      std::vector<unsigned int> dimSizes;
      std::vector<T>            values;
    };
  }
};

%union {
  simit::LiteralTensor      *literal_tensor;
  simit::DenseLiteralTensor *dense_literal_tensor;
  TensorValues<double>      *float_values;
  TensorValues<int>         *int_values;
};

%type                <Value> literal;
%type       <literal_tensor> tensor_literal;
%type <dense_literal_tensor> dense_tensor_literal;
%type <dense_literal_tensor> scalar_literal;

%type <float_values> float_dense_tensor_literal;
%type <float_values> float_dense_ndtensor_literal;
%type <float_values> float_dense_matrix_literal;
%type <float_values> float_dense_vector_literal;

%type <int_values> int_dense_tensor_literal;
%type <int_values> int_dense_ndtensor_literal;
%type <int_values> int_dense_matrix_literal;
%type <int_values> int_dense_vector_literal;

literal
  : element_literal
  | tensor_literal

element_literal
  :

tensor_literal
  : dense_tensor_literal
  | scalar_literal

%code {
  Shape *dimSizesToShape(const vector<unsigned int> &dimSizes) {
    auto dims = std::vector<Dimension*>();
    for (auto rit=dimSizes.rbegin(); rit!=dimSizes.rend(); ++rit) {
      dims.push_back(new Dimension(*rit));
    }
    return new Shape(dims);
  }
};

dense_tensor_literal
  : "[" float_dense_tensor_literal "]" {
    auto values = unique_ptr<TensorValues<double>>($2);
    Shape *shape = dimSizesToShape(values->dimSizes);
    auto type = new NDTensorType(shape, new ScalarType(ScalarType::FLOAT));
    $$ = new DenseLiteralTensor(type, values->values.data());
  }
  | "[" int_dense_tensor_literal "]" {
    auto values = unique_ptr<TensorValues<int>>($2);
    Shape *shape = dimSizesToShape(values->dimSizes);
    auto type = new NDTensorType(shape, new ScalarType(ScalarType::INT));
    $$ = new DenseLiteralTensor(type, values->values.data());
  }

float_dense_tensor_literal
  : float_dense_matrix_literal {
    // If the matrix has only one column then we discard that dimension and
    // treat it as a vector.
    if ($1->dimSizes[$1->dimSizes.size()-1] == 1) {
      $1->dimSizes.pop_back();
    }
  }
  | float_dense_ndtensor_literal

float_dense_ndtensor_literal
  : "[" float_dense_matrix_literal "]" {
    $$ = $2;
    $$->addDimension();
  }
  | float_dense_ndtensor_literal "," "[" float_dense_matrix_literal "]" {
    auto  left = unique_ptr<TensorValues<double>>($1);
    auto right = unique_ptr<TensorValues<double>>($4);

    string errorStr;
    if(!left->dimensionsMatch(*right, &errorStr)) {
      REPORT_ERROR(errorStr, @2);
    }
    left->merge(*right);
    $$ = left.release();
  }

float_dense_matrix_literal
  : float_dense_vector_literal {
    $$ = $1;
    $$->addDimension();
  }
  | float_dense_matrix_literal ";" float_dense_vector_literal {
    auto  left = unique_ptr<TensorValues<double>>($1);
    auto right = unique_ptr<TensorValues<double>>($3);

    string errorStr;
    if(!left->dimensionsMatch(*right, &errorStr)) {
      REPORT_ERROR(errorStr, @2);
    }

    left->merge(*right);
    $$ = left.release();
  }

float_dense_vector_literal
  : FLOAT_LITERAL {
    $$ = new TensorValues<double>();
    $$->addValue($1);
  }
  | float_dense_vector_literal "," FLOAT_LITERAL {
    $$ = $1;
    $$->addValue($3);
  }

int_dense_tensor_literal
  : int_dense_matrix_literal {
    // If the matrix has only one column then we discard that dimension and
    // treat it as a vector.
    if ($1->dimSizes[$1->dimSizes.size()-1] == 1) {
      $1->dimSizes.pop_back();
    }
  }
  | int_dense_ndtensor_literal

int_dense_ndtensor_literal
  : "[" int_dense_matrix_literal "]" {
    $$ = $2;
    $$->addDimension();
  }
  | int_dense_ndtensor_literal "," "[" int_dense_matrix_literal "]" {
    auto  left = unique_ptr<TensorValues<int>>($1);
    auto right = unique_ptr<TensorValues<int>>($4);

    string errorStr;
    if(!left->dimensionsMatch(*right, &errorStr)) {
      REPORT_ERROR(errorStr, @2);
    }
    left->merge(*right);
    $$ = left.release();
  }

int_dense_matrix_literal
  : int_dense_vector_literal {
    $$ = $1;
    $$->addDimension();
  }
  | int_dense_matrix_literal ";" int_dense_vector_literal {
    auto  left = unique_ptr<TensorValues<int>>($1);
    auto right = unique_ptr<TensorValues<int>>($3);

    string errorStr;
    if(!left->dimensionsMatch(*right, &errorStr)) {
      REPORT_ERROR(errorStr, @2);
    }

    left->merge(*right);
    $$ = left.release();
  }

int_dense_vector_literal
  : INT_LITERAL {
    $$ = new TensorValues<int>();
    $$->addValue($1);
  }
  | int_dense_vector_literal "," INT_LITERAL {
    $$ = $1;
    $$->addValue($3);
  }

scalar_literal
  : INT_LITERAL {
    $$ = new DenseLiteralTensor(new ScalarType(ScalarType::INT), &$1);
  }
  | FLOAT_LITERAL {
    $$ = new DenseLiteralTensor(new ScalarType(ScalarType::FLOAT), &$1);
  }

// Tests
test
  : TEST test_stmt_block {
    tests.push_back(simit::Test("MyTest"));
  }

test_stmt_block
  : /* empty */
  | test_stmt_block test_stmt

test_stmt
  : stmt
  | expr "->" literal ";" {
    delete $literal;
  }
%%
