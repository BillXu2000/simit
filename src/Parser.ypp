%code top{
  #include "Logger.h"
  #include "Program.h"
  #include <stdlib.h>
  #include <assert.h>
  #include <iostream>
  using namespace std;
}

%code requires {
  #include "IR.h"
  #include "Test.h"
  using namespace Simit;
}

%require "3.0.0"
%define parse.error verbose
%define parse.lac full
%locations
%pure-parser

%parse-param{Simit::Program *program}

%union {
  int    num;
  double fnum;
  const  char *string;

  Simit::Test   *test;
  Simit::IRNode *node;
}
%destructor { free((void*)($$)); } <string>
%destructor { delete $$; } <test>

%type <test> test

%code {
  #include "Scanner.h"
  void yyerror(YYLTYPE * loc, Simit::Program *program, const char *s);
}

%token UNKNOWN

// Literals
%right    "="
%nonassoc "\\"               // solve
%left     "==" "!="
%left     "<" ">" "<=" ">="
%left     "-" "+"
%left     "*" "/"
%left     NEG                // negation
%right    "^"                // exponentiation
%right    "'"                // transpose

%token <num>    INT_LITERAL    "int literal"
%token <fnum>   FLOAT_LITERAL  "float literal"
%token <string> STRING_LITERAL "string literal"
%token <string> IDENT          "identifier"

// Keywords
%token INT       "int"
%token FLOAT     "float"
%token STRUCT    "struct"
%token CONST     "const"
%token EXTERN    "extern"
%token PROC      "proc"
%token FUNC      "func"
%token TENSOR    "Tensor"
%token MAP       "map"
%token TO        "to"
%token WITH      "with"
%token REDUCE    "reduce"
%token WHILE     "while"
%token IF        "if"
%token ELIF      "elif"
%token ELSE      "else"
%token BLOCKEND  "end"
%token RETURN    "return"
%token TEST

%token RARROW    "->"
%token LP        "("
%token RP        ")"
%token LB        "["
%token RB        "]"
%token LC        "{"
%token RC        "}"
%token LA        "<"
%token RA        ">"
%token COMMA     ","
%token PERIOD    "."
%token COL       ":"
%token SEMICOL   ";"

%token ASSIGN    "="
%token PLUS      "+"
%token MINUS     "-"
%token STAR      "*"
%token SLASH     "/"
%token EXP       "^"
%token TRANSPOSE "'"
%token BACKSLASH "\\"

%token EQ        "=="
%token NE        "!="
%token LE        "<="
%token GE        ">="

// End of file
%token END 0 "end of file"


%start program
%%
program
  : /* empty */
  | program program_element

program_element
  : struct
  | procedure
  | function
  | stmt
  | extern
  | test {
    program->addTest($1);
  }

// Externs
extern
  : "extern" IDENT type "{" "}" ";"
  | "extern" IDENT type "[" endpoints "]" "{" "}" ";"

endpoints
  : IDENT
  | endpoints "," IDENT


// Structs
struct
  : "struct" IDENT struct_decl_block

struct_decl_block
  : /* empty */
  | struct_decl_list BLOCKEND

struct_decl_list
  : /* empty */
  | field_decl struct_decl_list

field_decl
  : var_decl  ";"


// Procedures and functions
procedure
  : PROC IDENT stmt_block BLOCKEND

function
  : function_header stmt_block BLOCKEND

function_header
  : FUNC IDENT "(" params ")" results

params
 : /* empty */
 | param_list

results
  : /* empty */
  | RARROW "(" param_list ")"

param_list
  : var_decl
  | param_list "," var_decl


// Types
type
  : object_type
  | tensor_type

object_type
  : IDENT

tensor_type
  : scalar_type
  | TENSOR shape  "(" scalar_type ")" { }

shape
  : /* empty */
  | shape "[" dimension_list "]"

dimension_list
  : dimension
  | dimension_list "," dimension

dimension
  : INT_LITERAL
  | IDENT
  | "*"

scalar_type
  : INT
  | FLOAT


// Statements
stmt_block
  : /* empty */
  | stmt_block stmt

stmt
  : const_stmt
  | if_stmt
  | return_stmt
  | assign_stmt
  | expr_stmt

const_stmt
  : "const" var_decl "=" literal ";"

if_stmt
  : "if" expr stmt_block else_clauses BLOCKEND

else_clauses
  : /* empty */
  | elif_clauses "else" stmt_block

elif_clauses
  : /* empty */
  | elif_clauses "elif" expr stmt_block


return_stmt
  : "return" ";"

assign_stmt
  : expr_list "=" expr_list ";"

var_list
  : IDENT
  | var_list "," IDENT

expr_stmt
  : ";"
  | expr ";"


// Expressions
expr
  : IDENT
  | FLOAT_LITERAL
  | INT_LITERAL
  | STRING_LITERAL

  | expr "\\" expr
  | expr "+" expr
  | expr "-" expr
  | expr "*" expr
  | expr "/" expr
  |      "-" expr  %prec NEG
  | expr "'"
  | expr "^" expr

  | expr "==" expr
  | expr "!=" expr
  | expr "<"  expr
  | expr ">"  expr
  | expr "<=" expr
  | expr ">=" expr

  | "(" expr ")"
  | expr ":" expr
  | call_expr
  | field_expr
  | index_expr
  | map_expr

field_expr
  : expr "." expr

call_expr
  : expr "(" ")"
  | expr "(" expr_list ")"

expr_list
  : expr
  | expr_list "," expr


// Map expressions
map_expr
  : "map" IDENT "to" IDENT with reduce

with
  : /* empty */
  | "with" IDENT

reduce
  : /* empty */
  | "reduce" reduction_op


// Index expressions
index_expr
  : reduction_indices expr

reduction_indices
  : /* empty */
  | reduction_indices reduction_index

reduction_index
  : reduction_op IDENT
  | reduction_op "{" IDENT "}"
  | IDENT "{" IDENT "}"

reduction_op
  : "+"
  | "-"


// Variables
var_decl
  : IDENT ":" type


// Literals
literal
  : scalar_literal
  | tensor_literal

tensor_literal
  : scalar_literal
  | "[" literal_list "]"

literal_list
  : scalar_literal
  | literal_list "," scalar_literal
  | literal_list ";" scalar_literal

scalar_literal
  : INT_LITERAL
  | FLOAT_LITERAL


// Tests
test
  : TEST test_stmt_block {
    $$ = new Simit::Test("MyTest");
  }

test_stmt_block
  : /* empty */
  | test_stmt_block test_stmt

test_stmt
  : stmt
  | expr "->" literal ";"
%%

void yyerror(YYLTYPE * loc, Simit::Program *program, const char *s) {
  string error = string(s) + " at " + to_string(loc->first_line) + ":" +
                 to_string(loc->first_column);
  program->addError(error);
}
