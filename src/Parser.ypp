%code top{
  #include <stdlib.h>
  #include <assert.h>
  #include <iostream>

  #include "Logger.h"
  #include "Program.h"
  #include "Util.h"
  using namespace std;
  using namespace simit;
}

%code requires {
  #include <vector>

  #include "IR.h"
  #include "Test.h"
  #include "Types.h"
}

%require "3.0.0"
%define parse.error verbose
%define parse.lac full
%locations
%pure-parser

%parse-param{simit::Program *program}

%union {
  // Primitive literals
  int                             num;
  double                          fnum;
  const char                     *string;

  simit::IRNode                  *node;

  // Types
  simit::Type                    *type;
  simit::ElementType             *element_type;
  simit::TensorType              *tensor_type;
  simit::ScalarType::Type         scalar_type;
  std::vector<simit::Shape*>     *shapes;
  simit::Shape                   *shape;
  std::vector<simit::Dimension*> *dimensions;
  simit::Dimension               *dimension;

  // Tests
  simit::Test                    *test;
}
%destructor { free((void*)($$)); } <string>
%destructor { delete $$; } <value>
%destructor { delete $$; } <dense_tensor_literal>
%destructor { delete $$; } <type, element_type, tensor_type>
%destructor { delete $$; } <shapes, shape, dimensions, dimension>
%destructor { delete $$; } <test>


%type <type>         type
%type <element_type> element_type
%type <tensor_type>  tensor_type
%type <shapes>       shapes
%type <shape>        shape
%type <dimensions>   dimensions
%type <dimension>    dimension
%type <scalar_type>  scalar_type

%type <test> test


%code {
  #include "Scanner.h"
  void yyerror(YYLTYPE * loc, simit::Program *program, const char *s);
}

%token UNKNOWN

// Literals
%right    "="
%nonassoc "\\"               // solve
%left     "==" "!="
%left     "<" ">" "<=" ">="
%left     "-" "+"
%left     "*" "/"
%left     NEG                // negation
%right    "^"                // exponentiation
%right    "'"                // transpose

%token <num>    INT_LITERAL    "int literal"
%token <fnum>   FLOAT_LITERAL  "float literal"
%token <string> STRING_LITERAL "string literal"
%token <string> IDENT          "identifier"

// Keywords
%token INT       "int"
%token FLOAT     "float"
%token STRUCT    "struct"
%token CONST     "const"
%token EXTERN    "extern"
%token PROC      "proc"
%token FUNC      "func"
%token TENSOR    "Tensor"
%token MAP       "map"
%token TO        "to"
%token WITH      "with"
%token REDUCE    "reduce"
%token WHILE     "while"
%token IF        "if"
%token ELIF      "elif"
%token ELSE      "else"
%token BLOCKEND  "end"
%token RETURN    "return"
%token TEST

%token RARROW    "->"
%token LP        "("
%token RP        ")"
%token LB        "["
%token RB        "]"
%token LC        "{"
%token RC        "}"
%token LA        "<"
%token RA        ">"
%token COMMA     ","
%token PERIOD    "."
%token COL       ":"
%token SEMICOL   ";"

%token ASSIGN    "="
%token PLUS      "+"
%token MINUS     "-"
%token STAR      "*"
%token SLASH     "/"
%token EXP       "^"
%token TRANSPOSE "'"
%token BACKSLASH "\\"

%token EQ        "=="
%token NE        "!="
%token LE        "<="
%token GE        ">="

// End of file
%token END 0 "end of file"


%start program
%%
program
  : /* empty */
  | program program_element

program_element
  : struct
  | procedure
  | function
  | stmt
  | extern
  | test {
    program->addTest($1);
  }

// Externs
extern
  : "extern" IDENT type "{" "}" ";" {
    free((void*)$IDENT);
    delete $type;
  }
  | "extern" IDENT type "[" endpoints "]" "{" "}" ";" {
    free((void*)$IDENT);
    delete $type;
  }

endpoints
  : IDENT {
    free((void*)$IDENT);
  }
  | endpoints "," IDENT {
    free((void*)$IDENT);
  }


// Structs
struct
  : "struct" IDENT struct_decl_block {
    free((void*)$IDENT);
  }

struct_decl_block
  : /* empty */
  | struct_decl_list BLOCKEND

struct_decl_list
  : /* empty */
  | field_decl struct_decl_list

field_decl
  : var_decl  ";"


// Procedures and functions
procedure
  : PROC IDENT stmt_block BLOCKEND {
    free((void*)$IDENT);
  }

function
  : function_header stmt_block BLOCKEND

function_header
  : FUNC IDENT "(" params ")" results {
    free((void*)$IDENT);
  }

params
 : /* empty */
 | param_list

results
  : /* empty */
  | RARROW "(" param_list ")"

param_list
  : var_decl
  | param_list "," var_decl


// Statements
stmt_block
  : /* empty */
  | stmt_block stmt

stmt
  : const_stmt
  | if_stmt
  | return_stmt
  | assign_stmt
  | expr_stmt

const_stmt
  : "const" var_decl "=" literal ";" {}

if_stmt
  : "if" expr stmt_block else_clauses BLOCKEND

else_clauses
  : /* empty */
  | elif_clauses "else" stmt_block

elif_clauses
  : /* empty */
  | elif_clauses "elif" expr stmt_block

return_stmt
  : "return" ";"

assign_stmt
  : expr_list "=" expr_list ";"

expr_stmt
  : ";"
  | expr ";"


// Expressions
expr
  : IDENT {
    free((void*)$IDENT);
  }
  | FLOAT_LITERAL
  | INT_LITERAL
  | STRING_LITERAL

  | expr "\\" expr
  | expr "+" expr
  | expr "-" expr
  | expr "*" expr
  | expr "/" expr
  |      "-" expr  %prec NEG
  | expr "'"
  | expr "^" expr

  | expr "==" expr
  | expr "!=" expr
  | expr "<"  expr
  | expr ">"  expr
  | expr "<=" expr
  | expr ">=" expr

  | "(" expr ")"
  | expr ":" expr
  | call_expr
  | field_expr
  | index_expr
  | map_expr

field_expr
  : expr "." expr

call_expr
  : expr "(" ")"
  | expr "(" expr_list ")"

expr_list
  : expr
  | expr_list "," expr


// Map expressions
map_expr
  : "map" IDENT[target] "to" IDENT[neighbor] with reduce {
    free((void*)$target);
    free((void*)$neighbor);
  }

with
  : /* empty */
  | "with" IDENT {
    free((void*)$IDENT);
  }

reduce
  : /* empty */
  | "reduce" reduction_op


// Index expressions
index_expr
  : reduction_indices expr

reduction_indices
  : /* empty */
  | reduction_indices reduction_index

reduction_index
  : reduction_op IDENT {
    free((void*)$IDENT);
  }
  | reduction_op "{" IDENT "}" {
    free((void*)$IDENT);
  }
  | IDENT[rfunc] "{" IDENT[rval] "}" {
    free((void*)$rfunc);
    free((void*)$rval);
  }

reduction_op
  : "+"
  | "-"


// Variables
var_decl
  : IDENT ":" type {
    delete $type;
    free((void*)$IDENT);
  }


// Types
type
  : element_type {
    $$ = $1;
  }
  | tensor_type {
    $$ = $1;
  }

element_type
  : IDENT {
    $$ = new ElementType();
    free((void*)$IDENT);
  }

tensor_type
  : scalar_type {
    $$ = new ScalarType($scalar_type);
  }
  | TENSOR shapes "(" scalar_type ")" {
    $$ = new ScalarType($scalar_type);
    typedef vector<Shape*>::reverse_iterator shapes_rit_t;
    for (shapes_rit_t rit = $shapes->rbegin(); rit != $shapes->rend(); ++rit) {
      $$ = new NDTensorType(*rit, $$);
    }
    delete $shapes;
  }

shapes
  : /* empty */ {
    $$ = new vector<Shape*>();
  }
  | shapes shape {
    $$ = $1;
    $$->push_back($shape);
  }

shape
  : "[" dimensions "]" {
    $$ = new Shape(*$dimensions);
    delete $dimensions;
  }

dimensions
  : dimension {
    $$ = new vector<Dimension*>();
    $$->push_back($dimension);
  }
  | dimensions "," dimension {
    $$ = $1;
    $$->push_back($dimension);
  }

dimension
  : INT_LITERAL {
    $$ = new Dimension($INT_LITERAL);
  }
  | IDENT {
    free((void*)$IDENT);
    $$ = new Dimension(123456789);  // TODO: This needs to be a set dimension
  }
  | "*" {
    $$ = new Dimension();
  }

scalar_type
  : INT {
    $$ = ScalarType::INT;
  }
  | FLOAT {
    $$ = ScalarType::FLOAT;
  }

// Literals
literal
  : tensor_literal

tensor_literal
  : dense_tensor_literal
  | scalar_literal

dense_tensor_literal
  : "[" float_dense_tensor_literal "]"
  | "["   int_dense_tensor_literal "]"

float_dense_tensor_literal
  : float_dense_matrix_literal
  | "[" float_dense_tensor_literal "]" "," "[" float_dense_matrix_literal "]"

float_dense_vector_literal
  : FLOAT_LITERAL
  | float_dense_vector_literal "," FLOAT_LITERAL

float_dense_matrix_literal
  : float_dense_vector_literal
  | float_dense_matrix_literal ";" float_dense_vector_literal

int_dense_tensor_literal
  : int_dense_matrix_literal
  | "[" int_dense_tensor_literal "]" "," "[" int_dense_matrix_literal "]"

int_dense_vector_literal
  : INT_LITERAL
  | int_dense_vector_literal "," INT_LITERAL

int_dense_matrix_literal
  : int_dense_vector_literal
  | int_dense_matrix_literal ";" int_dense_vector_literal

scalar_literal
  : INT_LITERAL
  | FLOAT_LITERAL


// Tests
test
  : TEST test_stmt_block {
    $$ = new simit::Test("MyTest");
  }

test_stmt_block
  : /* empty */
  | test_stmt_block test_stmt

test_stmt
  : stmt
  | expr "->" literal ";"
%%

void yyerror(YYLTYPE * loc, simit::Program *program, const char *s) {
  string error = string(s) + " at " + to_string(loc->first_line) + ":" +
                 to_string(loc->first_column);
  program->addError(error);
}
