%code top{
  #include <stdlib.h>
  #include <assert.h>
  #include <iostream>
  #include <algorithm>

  #include "Logger.h"
  #include "Program.h"
  #include "Util.h"
  using namespace std;
  using namespace simit;
}

%code requires {
  #include <vector>

  #include "IR.h"
  #include "Test.h"
  #include "Types.h"
}

%require "3.0.0"
%define parse.error verbose
%define parse.lac full
%locations
%pure-parser

%parse-param{simit::Program *program}

%union {
  // Primitive literals
  int                               num;
  double                            fnum;
  const char                       *string;

  // Values
  simit::Value                     *value;

  // Tests
  simit::Test                      *test;
}
%destructor {} <num> <fnum> <scalar_type>
%destructor { free((void*)($$)); } <string>
%destructor { delete $$; } <*>

%type <test> test


%code {
  #include "Scanner.h"
  void yyerror(YYLTYPE * loc, simit::Program *program, const char *error);
}

%token UNKNOWN

// Literals
%right    "="
%nonassoc "\\"               // solve
%left     "==" "!="
%left     "<" ">" "<=" ">="
%left     "-" "+"
%left     "*" "/"
%left     NEG                // negation
%right    "^"                // exponentiation
%right    "'"                // transpose

%token <num>    INT_LITERAL    "int literal"
%token <fnum>   FLOAT_LITERAL  "float literal"
%token <string> STRING_LITERAL "string literal"
%token <string> IDENT          "identifier"

// Keywords
%token INT       "int"
%token FLOAT     "float"
%token STRUCT    "struct"
%token CONST     "const"
%token EXTERN    "extern"
%token PROC      "proc"
%token FUNC      "func"
%token TENSOR    "Tensor"
%token MAP       "map"
%token TO        "to"
%token WITH      "with"
%token REDUCE    "reduce"
%token WHILE     "while"
%token IF        "if"
%token ELIF      "elif"
%token ELSE      "else"
%token BLOCKEND  "end"
%token RETURN    "return"
%token TEST

%token RARROW    "->"
%token LP        "("
%token RP        ")"
%token LB        "["
%token RB        "]"
%token LC        "{"
%token RC        "}"
%token LA        "<"
%token RA        ">"
%token COMMA     ","
%token PERIOD    "."
%token COL       ":"
%token SEMICOL   ";"

%token ASSIGN    "="
%token PLUS      "+"
%token MINUS     "-"
%token STAR      "*"
%token SLASH     "/"
%token EXP       "^"
%token TRANSPOSE "'"
%token BACKSLASH "\\"

%token EQ        "=="
%token NE        "!="
%token LE        "<="
%token GE        ">="

// End of file
%token END 0 "end of file"


%start program
%%
program
  : /* empty */
  | program program_element

program_element
  : struct
  | procedure
  | function
  | stmt
  | extern
  | test {
    program->addTest($1);
  }

// Externs
extern
  : "extern" IDENT type "{" "}" ";" {
    free((void*)$IDENT);
    delete $type;
  }
  | "extern" IDENT type "[" endpoints "]" "{" "}" ";" {
    free((void*)$IDENT);
    delete $type;
  }

endpoints
  : IDENT {
    free((void*)$IDENT);
  }
  | endpoints "," IDENT {
    free((void*)$IDENT);
  }


// Structs
struct
  : "struct" IDENT struct_decl_block {
    free((void*)$IDENT);
  }

struct_decl_block
  : /* empty */
  | struct_decl_list BLOCKEND

struct_decl_list
  : /* empty */
  | field_decl struct_decl_list

field_decl
  : var_decl  ";"


// Procedures and functions
procedure
  : PROC IDENT stmt_block BLOCKEND {
    free((void*)$IDENT);
  }

function
  : function_header stmt_block BLOCKEND

function_header
  : FUNC IDENT "(" params ")" results {
    free((void*)$IDENT);
  }

params
 : /* empty */
 | param_list

results
  : /* empty */
  | RARROW "(" param_list ")"

param_list
  : var_decl
  | param_list "," var_decl


// Statements
stmt_block
  : /* empty */
  | stmt_block stmt

stmt
  : const_stmt
  | if_stmt
  | return_stmt
  | assign_stmt
  | expr_stmt

const_stmt
  : "const" IDENT ":" tensor_type "=" tensor_literal ";" {
    // If $type is a matrix whose outer dimension is 1, and $tensor_literal is
    // a vector then we cast $tensor_literal to a 1xn matrix
    if ($tensor_type->getOrder() == 2 && $tensor_literal->getOrder() == 1) {
      $tensor_literal->cast($tensor_type);
    }
    else {
      delete $tensor_type;
    }

    // Typecheck: $type and $tensor_literal->getType() must be equivalent.
    // TODO:

    $tensor_literal->setName($IDENT);
    free((void*)$IDENT);
  }
  | "const" IDENT ":" element_type "=" element_literal ";" {
    free((void*)$IDENT);
    delete $element_type;
  }

if_stmt
  : "if" expr stmt_block else_clauses BLOCKEND

else_clauses
  : /* empty */
  | elif_clauses "else" stmt_block

elif_clauses
  : /* empty */
  | elif_clauses "elif" expr stmt_block

return_stmt
  : "return" ";"

assign_stmt
  : expr_list "=" expr_list ";"

expr_stmt
  : ";"
  | expr ";"


// Expressions
expr
  : IDENT {
    free((void*)$IDENT);
  }
  | FLOAT_LITERAL
  | INT_LITERAL
  | STRING_LITERAL

  | expr "\\" expr
  | expr "+" expr
  | expr "-" expr
  | expr "*" expr
  | expr "/" expr
  |      "-" expr  %prec NEG
  | expr "'"
  | expr "^" expr

  | expr "==" expr
  | expr "!=" expr
  | expr "<"  expr
  | expr ">"  expr
  | expr "<=" expr
  | expr ">=" expr

  | "(" expr ")"
  | expr ":" expr
  | call_expr
  | field_expr
  | index_expr
  | map_expr

field_expr
  : expr "." expr

call_expr
  : expr "(" ")"
  | expr "(" expr_list ")"

expr_list
  : expr
  | expr_list "," expr


// Map expressions
map_expr
  : "map" IDENT[target] "to" IDENT[neighbor] with reduce {
    free((void*)$target);
    free((void*)$neighbor);
  }

with
  : /* empty */
  | "with" IDENT {
    free((void*)$IDENT);
  }

reduce
  : /* empty */
  | "reduce" reduction_op


// Index expressions
index_expr
  : reduction_indices expr

reduction_indices
  : /* empty */
  | reduction_indices reduction_index

reduction_index
  : reduction_op IDENT {
    free((void*)$IDENT);
  }
  | reduction_op "{" IDENT "}" {
    free((void*)$IDENT);
  }
  | IDENT[rfunc] "{" IDENT[rval] "}" {
    free((void*)$rfunc);
    free((void*)$rval);
  }

reduction_op
  : "+"
  | "-"


// Variables
var_decl
  : IDENT ":" type {
    delete $type;
    free((void*)$IDENT);
  }


// Types
%union {
  simit::Type                      *type;
  simit::ElementType               *element_type;
  simit::TensorType                *tensor_type;
  simit::TensorType::ComponentType  scalar_type;
  std::vector<simit::Shape*>       *shapes;
  simit::Shape                     *shape;
  std::vector<simit::Dimension*>   *dimensions;
  simit::Dimension                 *dimension;
};

%type <type>         type;
%type <element_type> element_type;
%type <tensor_type>  tensor_type;
%type <shapes>       shapes;
%type <shape>        shape;
%type <dimensions>   dimensions;
%type <dimension>    dimension;
%type <scalar_type>  scalar_type;

type
  : element_type {
    $$ = $element_type;
  }
  | tensor_type {
    $$ = $tensor_type;
  }

element_type
  : IDENT {
    $$ = new ElementType();
    free((void*)$IDENT);
  }

tensor_type
  : scalar_type {
    $$ = new ScalarType($scalar_type);
  }
  | TENSOR shapes "(" scalar_type ")" {
    $$ = new ScalarType($scalar_type);
    typedef vector<Shape*>::reverse_iterator shapes_rit_t;
    for (shapes_rit_t rit = $shapes->rbegin(); rit != $shapes->rend(); ++rit) {
      $$ = new NDTensorType(*rit, $$);
    }
    delete $shapes;
  }

shapes
  : /* empty */ {
    $$ = new vector<Shape*>();
  }
  | shapes shape {
    $$ = $1;
    $$->push_back($shape);
  }

shape
  : "[" dimensions "]" {
    $$ = new Shape(*$dimensions);
    delete $dimensions;
  }

dimensions
  : dimension {
    $$ = new vector<Dimension*>();
    $$->push_back($dimension);
  }
  | dimensions "," dimension {
    $$ = $1;
    $$->push_back($dimension);
  }

dimension
  : INT_LITERAL {
    $$ = new Dimension($INT_LITERAL);
  }
  | IDENT {
    free((void*)$IDENT);
    $$ = new Dimension(123456789);  // TODO: This needs to be a set dimension
  }
  | "*" {
    $$ = new Dimension();
  }

scalar_type
  : INT {
    $$ = ScalarType::INT;
  }
  | FLOAT {
    $$ = ScalarType::FLOAT;
  }


// Literals
%code requires {
  #include <assert.h>
  namespace {
    template <typename T>
    class TensorValues {
     public:
      TensorValues() : dimSizes(1) {};

      void addValue(const T &val) {
        values.push_back(val);
        dimSizes[dimSizes.size()-1]++;
      }
      void addDimension() { dimSizes.push_back(1); }

      bool dimensionsMatch(const TensorValues<T> &other, std::string *errors) {
        assert(errors != NULL);
        std::string mismatchError = "error, missmatched dimension sizes";
        if (dimSizes.size()-1 != other.dimSizes.size()) {
          *errors = mismatchError;
          return false;
        }

        for (unsigned int i=0; i<dimSizes.size()-1; ++i) {
          if (dimSizes[i] != other.dimSizes[i]) {
            *errors = mismatchError;
            return false;
          }
        }
        return true;
      }

      void merge(const TensorValues<T> &other) {
        values.insert(values.end(), other.values.begin(), other.values.end());
        dimSizes[dimSizes.size()-1]++;
      }

      std::vector<unsigned int> dimSizes;
      std::vector<T>            values;
    };
  }
};

%union {
  simit::LiteralTensor      *literal_tensor;
  simit::DenseLiteralTensor *dense_literal_tensor;
  TensorValues<double>      *float_values;
  TensorValues<int>         *int_values;
};

%type                <value> literal;
%type       <literal_tensor> tensor_literal;
%type <dense_literal_tensor> dense_tensor_literal;
%type <dense_literal_tensor> scalar_literal;

%type <float_values> float_dense_tensor_literal;
%type <float_values> float_dense_ndtensor_literal;
%type <float_values> float_dense_matrix_literal;
%type <float_values> float_dense_vector_literal;

%type <int_values> int_dense_tensor_literal;
%type <int_values> int_dense_ndtensor_literal;
%type <int_values> int_dense_matrix_literal;
%type <int_values> int_dense_vector_literal;

literal
  : element_literal
  | tensor_literal

element_literal
  :

tensor_literal
  : dense_tensor_literal
  | scalar_literal

%code {
  Shape *dimSizesToShape(const vector<unsigned int> &dimSizes) {
    auto dims = std::vector<Dimension*>();
    for (auto rit=dimSizes.rbegin(); rit!=dimSizes.rend(); ++rit) {
      dims.push_back(new Dimension(*rit));
    }
    return new Shape(dims);
  }
};

dense_tensor_literal
  : "[" float_dense_tensor_literal "]" {
    Shape *shape = dimSizesToShape($2->dimSizes);
    auto type = new NDTensorType(shape, new ScalarType(ScalarType::FLOAT));
    $$ = new DenseLiteralTensor(type, $2->values.data());
    delete $2;
  }
  | "[" int_dense_tensor_literal "]" {
    Shape *shape = dimSizesToShape($2->dimSizes);
    auto type = new NDTensorType(shape, new ScalarType(ScalarType::INT));
    $$ = new DenseLiteralTensor(type, $2->values.data());
    delete $2;
  }

float_dense_tensor_literal
  : float_dense_matrix_literal {
    // If the matrix has only one column then we discard that dimension and
    // treat it as a vector.
    if ($1->dimSizes[$1->dimSizes.size()-1] == 1) {
      $1->dimSizes.pop_back();
    }
  }
  | float_dense_ndtensor_literal

float_dense_ndtensor_literal
  : "[" float_dense_matrix_literal "]" {
    $$ = $2;
    $$->addDimension();
  }
  | float_dense_ndtensor_literal "," "[" float_dense_matrix_literal "]" {
    string errors;
    if(!$1->dimensionsMatch(*$4, &errors)) {
      yyerror(&@2, program, errors.c_str());
      YYERROR;
    }

    $$ = $1;
    $1->merge(*$4);
    delete $4;
  }

float_dense_matrix_literal
  : float_dense_vector_literal {
    $$ = $1;
    $$->addDimension();
  }
  | float_dense_matrix_literal ";" float_dense_vector_literal {
    string errors;
    if(!$1->dimensionsMatch(*$3, &errors)) {
      yyerror(&@2, program, errors.c_str());
      YYERROR;
    }

    $$ = $1;
    $1->merge(*$3);
    delete $3;
  }

float_dense_vector_literal
  : FLOAT_LITERAL {
    $$ = new TensorValues<double>();
    $$->addValue($1);
  }
  | float_dense_vector_literal "," FLOAT_LITERAL {
    $$ = $1;
    $$->addValue($3);
  }

int_dense_tensor_literal
  : int_dense_matrix_literal {
    // If the matrix has only one column then we discard that dimension and
    // treat it as a vector.
    if ($1->dimSizes[$1->dimSizes.size()-1] == 1) {
      $1->dimSizes.pop_back();
    }
  }
  | int_dense_ndtensor_literal

int_dense_ndtensor_literal
  : "[" int_dense_matrix_literal "]" {
    $$ = $2;
    $$->addDimension();
  }
  | int_dense_ndtensor_literal "," "[" int_dense_matrix_literal "]" {
    string errors;
    if(!$1->dimensionsMatch(*$4, &errors)) {
      yyerror(&@2, program, errors.c_str());
      YYERROR;
    }

    $$ = $1;
    $1->merge(*$4);
    delete $4;
  }

int_dense_matrix_literal
  : int_dense_vector_literal {
    $$ = $1;
    $$->addDimension();
  }
  | int_dense_matrix_literal ";" int_dense_vector_literal {
    string errors;
    if(!$1->dimensionsMatch(*$3, &errors)) {
      yyerror(&@2, program, errors.c_str());
      YYERROR;
    }

    $$ = $1;
    $1->merge(*$3);
    delete $3;
  }

int_dense_vector_literal
  : INT_LITERAL {
    $$ = new TensorValues<int>();
    $$->addValue($1);
  }
  | int_dense_vector_literal "," INT_LITERAL {
    $$ = $1;
    $$->addValue($3);
  }

scalar_literal
  : INT_LITERAL {
    $$ = new DenseLiteralTensor(new ScalarType(ScalarType::INT), &$1);
  }
  | FLOAT_LITERAL {
    $$ = new DenseLiteralTensor(new ScalarType(ScalarType::FLOAT), &$1);
  }

// Tests
test
  : TEST test_stmt_block {
    $$ = new simit::Test("MyTest");
  }

test_stmt_block
  : /* empty */
  | test_stmt_block test_stmt

test_stmt
  : stmt
  | expr "->" literal ";"
%%

void yyerror(YYLTYPE * loc, simit::Program *program, const char *error) {
  string errorStr = string(error) + " at " + to_string(loc->first_line) + ":" +
                    to_string(loc->first_column);
  program->addError(errorStr);
}
