element Point
  x     : vector[3](float);
  ox     : vector[3](float);
  v     : vector[3](float);
  m     : float;
  fixed : bool;
end

element Spring
  k  : float;
end

extern points  : set{Point};
extern springs : set{Spring}(points,points);

const g    = [0.0, 9.8, 0.0]';
const h    = 2e-5;
%const damp = 0.01;

func acceleration(s : Spring, p : (Point*2))
    -> a : vector[points](vector[3](float))
  dx = p(1).x - p(0).x;
  l = norm(dx);
  restl = norm(p(1).ox - p(0).ox);
  U = dx/l;
  f = s.k * (l-restl);
  fe0 = f*U;

  if not p(0).fixed
    a(p(0)) =  fe0 / p(0).m;
  end
  if not p(1).fixed
    a(p(1)) = -fe0 / p(1).m;
  end
end

func acc(p: Point)
    -> aa : vector[points](vector[3](float))
  if not p.fixed
    aa(p) = g;
  end
end

export func timestep()
  a = map acceleration to springs reduce +;
  aa = map acc to points reduce +;
  points.v = points.v + h*(a + aa);
  points.x = points.x + points.v * h;
end
