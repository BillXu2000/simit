element Point
  x     : vector[3](float);
  v     : vector[3](float);
  m     : float;
  fixed : bool;
end

element Spring
  k  : float;
  l0 : float;
end

extern points  : set{Point};
extern springs : set{Spring}(points,points);

func compute_mass_damping(p : Point)
-> (MD  : matrix[points,points](matrix[3,3](float)),
    fmg : vector[points](vector[3](float)))
  h = 1.0e-2;
  viscous = 2.0e0;
  grav = [0.0, -9.81, 0.0]';
  I = [1.0, 0.0, 0.0; 0.0, 1.0, 0.0; 0.0, 0.0, 1.0];
  mass = p.m;
  if p.fixed
    MD(p,p) = 1.0;
  else
    MD(p,p) = (mass + h*viscous)*I;
    fmg(p) = mass*p.v + h*mass*grav;
  end
end

func compute_elasticity(s: Spring, p : (Point*2))
-> (K  : matrix[points,points](matrix[3,3](float)),
    fe : vector[points](vector[3](float)))
  h = 1.0e-2;
  I = [1.0, 0.0, 0.0; 0.0, 1.0, 0.0; 0.0, 0.0, 1.0];
  free0 = not p(0).fixed;
  free1 = not p(1).fixed;
  stiffness = s.k;
  % Spring force
  dx = p(1).x - p(0).x;
  l = norm(dx);
  U = dx/l;
  l0 = s.l0;
  f = stiffness*(l-l0);
  fe0 = h*f*U;
  if free0
    fe(p(0)) = fe0;
  end
  if free1
    fe(p(1)) = -fe0;
  end
  % Stiffness matrix
  UUt = U*U';
  k = h*h*((stiffness-f/l)*UUt + f/l*I);
  if free0 and free1
    K(p(0),p(0)) =  k;
    K(p(0),p(1)) = -k;
    K(p(1),p(0)) = -k;
    K(p(1),p(1)) =  k;
  else
    if free0
      K(p(0),p(0)) = k;
    end
    if free1
      K(p(1),p(1)) = k;
    end
  end
end

export func timestep()
  h = 1.0e-2;

  MD, fmg = map compute_mass_damping to points reduce +;
  K, fe = map compute_elasticity to springs reduce +;

  MDK = MD + K;
  f = fmg + fe;

  % We should not be resetting vguess to zero every time step
  vguess = points.v;

  tol = 1e-12;
  maxiters = 50;

  var r = f - (MDK*vguess);
  var p = r;
  var iter = 0;
  var v = vguess;
  var normr2 = r'*r;
  while (normr2 > tol) and (iter < maxiters)
    Ap = MDK * p;
    denom = p'*Ap;
    alpha = normr2 / denom;
    v = v + alpha * p;
    normr2old = normr2;
    r = r - alpha * Ap;
    normr2 = r'*r;
    beta = normr2 / normr2old;
    p = r + beta * p;
    iter = iter + 1;
  end
  %println iter;
  points.v = v;
  points.x = points.x + h * points.v;

end
