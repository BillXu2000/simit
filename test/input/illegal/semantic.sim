%%% bad-call-1
func foo(i : int)
end

proc main
  foo(:);
end

%%% bad-call-2
func foo(i : int)
end

proc main
  foo();
end

%%% bad-call-3
func foo(i : int)
end

proc main
  foo(1.0);
end

%%% bad-call-4
func foo(i : int)
end

func bar() -> (i : int, j : int)
end

func bazz()
end

proc main
  foo(bar()) + foo(bazz());
end

%%% bad-call-5
proc main
  cos(2.0, 3.0);
end

%%% bad-assign-1
proc main
  1 = 1;
end

%%% bad-assign-2
element E
  f : int;
end

func foo(inout a : (E * 2))
  a(1).f = 1;
end

%%% bad-set-type
element E
end

extern t : int;
extern V : set{E}(t);

%%% bad-tensor-type-1
element E
end

proc main
  var t : tensor[E](int);
end

%%% bad-tensor-type-2
proc main
  var t : tensor[2,2](int)';
end

%%% bad-tuple-type-1
func foo(a : (F * 2))
end

%%% bad-tuple-type-2
element F
end

func foo(a : (F * 0))
end

%%% redeclaration-1
element E
end

element E
end

%%% redeclaration-2
extern v : int;
extern v : int;

%%% redeclaration-3
proc main
end

proc main
end

%%% redeclaration-4
proc main
  var v : int;
  var v : int;
end

%%% bad-decl
const x : int = 1 + 2;

%%% bad-cond-1
proc main
  while 1
  end
end

%%% bad-cond-2
proc main
  if 1
  end
end

%%% bad-cond-3
proc main
  if true
  elif 1.0
  elif 1.0 + 2.0
  end
end

%%% bad-range-1
proc main
  var r : int;
  for i in r
  end
end

%%% bad-range-2
proc main
  for i in true:false
  end
end

%%% bad-print
element E
end

extern x : set{E};

proc main
  print x;
end

%%% bad-assign-1
func bar() -> (i : int)
end

proc main
  var t : float;
  t = bar();
end

%%% bad-assign-2
func bazz() -> (i : int, j : int)
end

proc main
  t = bazz();
end

%%% bad-tensor-access
proc main
  var t : tensor[1](int);
  t(1.0);
end

%%% bad-tensor-access-2
func fizz()
end

proc main
  var t : tensor[1](int);
  t(fizz());
end

%%% bad-tensor-access-3
func buzz() -> (i : int, j : int)
end

proc main
  var t : tensor[1](int);
  t(buzz());
end

%%% bad-tensor-access-4
proc main
  var t : tensor[1](float);
  t(1,2);
end

%%% bad-tuple-access-1
element e
end

func f(a : (e * 2))
  a(0,1);
end

%%% bad-tuple-access-2
element E
end

func f(a : (E * 2))
  a(:);
end

%%% bad-tuple-access-3
element E
end

func f(a : (E * 2))
  a(0.0 + 1.0);
end

%%% bad-tuple-access-4
element E
end

func fizz()
end

func f(a : (E * 2))
  a(fizz());
end

%%% bad-access
element E
end

extern x : set{E};

proc main
  x(1);
end

%%% bad-field-read-1
func buzz() -> (i : int, j : int)
end

proc main
  buzz().t;
end

%%% bad-field-read-2
func bar() -> (i : int)
end

proc main
  bar().t;
end

%%% bad-field-read-3
element E
end

func foo(a : E)
  a.e;
end

%%% bad-field-read-4
element G
  f : tensor[2,2](int);
end

extern S : set{G};

proc main
  S.f;
end

%%% write-to-readonly
func foo(i : int)
  i = 1;
end

%%% bad-dense-tensor-1
proc main
  t = [1, 2; 3];
end

%%% bad-dense-tensor-2
proc main
  t = [[1, 2], [1, 2; 3, 4]];
end

%%% bad-dense-tensor-3
proc main
  t = [0 1; 2.0 3.0];
end

%%% bad-init
proc main
  var t : int = 1.0;
end

%%% bad-add-1
proc main
  var t : tensor[2](int) = [1 2];
  var v : tensor[2](float) = [3.0 4.0];
  t + v;
end

%%% bad-add-2
proc main
  true - false;
end

%%% bad-mul-1
proc main
  t = [1 2];
  t * t;
end

%%% bad-mul-2
proc main
  N = [1 2; 3 4];
  M * N;
end

%%% bad-mul-3
proc main
  N = [1 2; 3 4];
  t = [1 2 3]';
  N * t;
end

%%% bad-mul-4
proc main
  N = [1 2; 3 4];
  t = [1 2 3];
  t * N;
end

%%% bad-mul-5
proc main
  M = [[[1 2],[3 4]],[[5 6], [7 8]]];
  M * M;
end

%%% bad-mul-6
proc main
  true * false;
end

%%% bad-mul-7
proc main
  1.0 * 2;
end

%%% bad-mul-8
proc main
  [1 2] * [1 2 3]';
end

%%% bad-mul-9
proc main
  [1 2; 3 4] * [1 2];
end

%%% bad-mul-10
proc main
  [1 2]' * [1 2; 3 4];
end

%%% bad-mul-11
proc main
  v = [1 2]';
  (v + v) * [1 2; 3 4];
end

%%% bad-div-1
proc main
  M = [[[1 2],[3 4]],[[5 6], [7 8]]];
  M / true;
end

%%% bad-div-2
proc main
  M = [[[1 2],[3 4]],[[5 6], [7 8]]];
  M / 2.0;
end

%%% bad-map-1
element E
end

extern V : set{E};
extern U : set{E}(V,V);

func f(v : E, u : (E * 1))
end

proc main
  map f to U;
end

%%% bad-map-2
element E
end

extern V : set{E};
extern U : set{E}(V,V);

func g(u : (E * 2))
end

proc main
  map g to U;
end

%%% bad-map-3
element E
end

extern V : set{E};
extern U : set{E}(V,V);

func h(f : float, v : E, u : (E * 2))
end

proc main
  map h to U;
end

%%% bad-map-4
element E
end

extern V : set{E};
extern U : set{E}(V,V);

func h(f : float, v : E, u : (E * 2))
end

proc main
  map h(1) to U;
end

%%% bad-map-5
func h(f : float)
end

proc main
  t = 1.0;
  map h to t; 
end

%%% undeclared-var
proc main
  z * z - 2;
end

%%% bad-and
proc main
  1 and 2;
end

%%% bad-eq-1
proc main
  s = [1 2];
  s == s;
end

%%% bad-eq-2
proc main
  1 == 2 == 2.0;
end

%%% bad-not
proc main
  not 1;
end

%%% bad-neg
proc main
  -true;
end
