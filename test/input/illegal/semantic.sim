%%% bad-call-1
func foo(i : int)
end

proc main
  foo(:);
end

%%% bad-call-2
func foo(i : int)
end

proc main
  foo();
end

%%% bad-assign-1
proc main
  1 = 1;
end

%%% bad-assign-2
element E
  f : int;
end

func foo(inout a : (E * 2))
  a(1).f = 1;
end

%%% bad-tensor-type
element E
end

proc main
  var t : tensor[E](int);
end

%%% bad-tuple-type-1
func foo(a : (F * 2))
end

%%% bad-tuple-type-2
element F
end

func foo(a : (F * 0))
end

%%% redeclaration-1
element E
end

element E
end

%%% redeclaration-2
extern v : int;
extern v : int;

%%% redeclaration-3
proc main
end

proc main
end

%%% redeclaration-4
proc main
  var v : int;
  var v : int;
end

%%% bad-cond-1
proc main
  while 1
  end
end

%%% bad-cond-2
proc main
  if 1
  end
end

%%% bad-cond-3
proc main
  if true
  elif 1.0
  elif 1.0 + 2.0
  end
end

%%% bad-range-1
proc main
  var r : int;
  for i in r
  end
end

%%% bad-range-2
proc main
  for i in true:false
  end
end

%%% bad-print
element E
end

extern x : set{E};

proc main
  print x;
end

%%% bad-assign-1
func bar() -> (i : int)
end

proc main
  var t : float;
  t = bar();
end

%%% bad-assign-2
func bazz() -> (i : int, j : int)
end

proc main
  t = bazz();
end

%FIXME: bad-tensor-access
%proc main
%  var t : tensor[1](int);
%  t(1.0);
%end

%%% bad-tensor-access-2
func fizz()
end

proc main
  var t : tensor[1](int);
  t(fizz());
end

%%% bad-tensor-access-3
func buzz() -> (i : int, j : int)
end

proc main
  var t : tensor[1](int);
  t(buzz());
end

%%% bad-tensor-access-4
proc main
  var t : tensor[1](float);
  t(1,2);
end

%%% bad-tuple-access-1
element e
end

func f(a : (e * 2))
  a(0,1);
end

%%% bad-tuple-access-2
element E
end

func f(a : (E * 2))
  a(:);
end

%%% bad-tuple-access-1
element E
end

func f(a : (E * 2))
  a(0.0 + 1.0);
end

%%% bad-access
element E
end

extern x : set{E};

proc main
  x(1);
end

%%% bad-field-read-1
func buzz() -> (i : int, j : int)
end

proc main
  buzz().t;
end

%%% bad-field-read-2
func bar() -> (i : int)
end

proc main
  bar().t;
end

%%% bad-field-read-3
element E
end

func foo(a : E)
  a.e;
end

%%% write-to-readonly
func foo(i : int)
  i = 1;
end

%%% bad-dense-tensor-1
proc main
  t = [1, 2; 3];
end

%%% bad-dense-tensor-2
proc main
  t = [[1, 2], [1, 2; 3, 4]];
end

%%% bad-dense-tensor-3
proc main
  t = [0 1; 2.0 3.0];
end

%%% bad-init
proc main
  var t : int = 1.0;
end

%%% bad-add-1
proc main
  var t : tensor[2](int) = [1 2];
  var v : tensor[2](float) = [3.0 4.0];
  t + v;
end

%%% bad-add-2
proc main
  true - false;
end

%%% bad-mul-1
proc main
  t = [1 2];
  t * t;
end

%%% bad-mul-2
proc main
  N = [1 2; 3 4];
  M * N;
end

%%% bad-mul-3
proc main
  N = [1 2; 3 4];
  t = [1 2 3]';
  N * t;
end

%%% bad-mul-4
proc main
  N = [1 2; 3 4];
  t = [1 2 3];
  t * N;
end

%%% bad-mul-5
proc main
  M = [[[1 2],[3 4]],[[5 6], [7 8]]];
  M * M;
end

%%% bad-mul-6
proc main
  true * false;
end

%%% bad-mul-7
proc main
  1.0 * 2;
end

%%% bad-div-1
proc main
  M = [[[1 2],[3 4]],[[5 6], [7 8]]];
  M / true;
end

%%% bad-div-2
proc main
  M = [[[1 2],[3 4]],[[5 6], [7 8]]];
  M / 2.0;
end
