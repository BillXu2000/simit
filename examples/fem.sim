element Point
  x : tensor[3](float);
end

element Hex
  mu: float;
  lambda: float;
end
const eye3      : tensor[3,3](float) = [1.0, 0.0, 0.0; 0.0, 1.0, 0.0; 0.0, 0.0, 1.0];
const quadrature : tensor[8,3](float)=
[-0.57735, -0.57735, -0.57735;
 -0.57735, -0.57735,  0.57735;
 -0.57735,  0.57735, -0.57735;
 -0.57735,  0.57735,  0.57735;
  0.57735, -0.57735, -0.57735;
  0.57735, -0.57735,  0.57735;
  0.57735,  0.57735, -0.57735;
  0.57735,  0.57735,  0.57735];

const qw : tensor[8,3](float)=
[-1.0, -1.0, -1.0;
 -1.0, -1.0,  1.0;
 -1.0,  1.0, -1.0;
 -1.0,  1.0,  1.0;
  1.0, -1.0, -1.0;
  1.0, -1.0,  1.0;
  1.0,  1.0, -1.0;
  1.0,  1.0,  1.0];
  
const eleSize: float=0.1;
  
extern points :set{Point};
extern elts : set{Hex}(points,points);
extern fe : tensor[points](tensor[3](float));

func PK1 (e : Hex, F:tensor[3,3](float)) -> (P:tensor[3,3](float))
  J = 1.0; %%%log(det(F));
  FT = F; %.inverse()';
  P = e.mu * (F - FT) + e.lambda * J * FT;
end

func dPdx (e : Hex, F:tensor[3,3](float), dF:tensor[3,3](float))
   -> (dP:tensor[3,3](float))
  J = 1.0; %log(det(F));
  Finv = F;%F.inverse();
  FinvT = Finv';
  dP = e.mu*dF;
  c1 = e.mu-e.lambda * J;
  dP = dP+c1 * FinvT*dF'*FinvT;
  dP = dP+e.lambda*FinvT; %trace(Finv*dF)*
end

func shapeFunGrad (p : tensor[3](float), i:int) -> (g:tensor[3](float))
  g(i,0) = (0.25/eleSize) * qw(i,0) * (1.0 + qw(i,1) * p(1)) * (1.0 + qw(i,2) * p(2));
  g(i,1) = (0.25/eleSize) * qw(i,1) * (1.0 + qw(i,0) * p(0)) * (1.0 + qw(i,2) * p(2));
  g(i,2) = (0.25/eleSize) * qw(i,2) * (1.0 + qw(i,0) * p(0)) * (1.0 + qw(i,1) * p(1));
end

func defGrad(p : tensor[3](float), ps : (Point*8)) -> (F : tensor[3,3](float))
  F = eye3;
end

func compute_intforce(e : Hex, ps : (Point*8)) ->
     (f : tensor[points](tensor[3](float)))
  F = defGrad(quadrature, ps);
  P = PK1(e, F);
  for p1 in ps
    N = shapeFunGrad(p);
    f[p1] = qw * P * N;
  end
end


proc main
	x = points.x;

	points.x = x;
end
