const stretchingStiffness : float = 1.0e4;
const bendingStiffness : float = 1.0e-4;
const timeStep : float = 0.001;

element Point
  x : tensor[3](float);
  v : tensor[3](float);
  m : float;
end

element Hinge
  restBendingAngle : float;
  restLength : float;
  restPerpLength: float;
end

element Face  
  precomputedStretchingMatrix : tensor[3,3](float);
  restLengths : tensor[3](float);
end

extern points : set{Point};
extern faces : set{Face}(points, points, points);
extern hinges: set{Hinge}(points, points, points, points);

func computeAngle(p1 : Point, p2 : Point, q1 : Point, q2 : Point) -> (theta : float)
  ev = p2.x - p1.x;
  n1 = cross(ev, q1.x - p1.x);
  n2 = cross(q2.x - p1.x, ev);
  mag = norm(ev);
  ev = ev/mag;
  theta = atan2( dot( cross(n1, n2), ev ), dot(n1, n2) );
end

func edgeVectors(pts : (Point*3)) -> (vec : tensor[3](tensor[3](float)))
  for i in 0:3
    int j = (i+1)%3;
    vec[i] = pts(j).x - pts(i).x;
  end
end

func precomputeMatrix(f : Face, pts : (Point*3))
  tensor[3](tensor[3](float)) uvs = edgeVectors(pts);
  A = 0.5 * norm( cross(uvs(2), uvs(1)) );
  for i in 0:3
    j = (i+1)%3;
    k = (i+2)%3;
    for l in i:3
      m = (i+1)%3;
      n = (i+2)%3;
      f.precomputedStretchingMatrix(i,l) = f.precomputedStretchingMatrix(l,i) = dot(uvs(k), uvs(m)) * dot(uvs(j),uvs(n)) + dot(uvs(k), uvs(n))*dot(uvs(j),uvs(m));
    end
  end
  f.precomputedStretchingMatrix /= (256.0 * A * A * A);
end

func precomputeFaceQuantities(f : Face, pts : (Point*3))
  precomputeMatrix(f, pts);
  vec = edgeVectors(pts);
  for i in 0:3
    restLengths(i) = norm(vec(i));
  end
end
  

func precomputeHingeQuantities(h : Hinge, pts : (Point*4) )
  p1 = pts(0);
  p2 = pts(1);
  q1 = pts(2);
  q2 = pts(3);
  theta = computeAngle(p1, p2, q1 q2);
  h.restDihedralAngle = theta;
  A1 = 0.5 * norm( cross(p2.x - p1.x, q1.x - p1.x) );
  A2 = 0.5 * norm( cross(p2.x - p1.x, q2.x - p1.x) );
  e0 = norm(p2.x - p1.x);
  h.restPerpLength = 2.0*(A1+A2)/(3.0 * e0);
  h.restLength = e0;
end

proc initializeClothPhysics
  map precomputeFaceQuantities to faces with points;
  map precomputeHingeQuantities to hinges with points;  
end

func dihedralAngleDerivatives(p1 : Point, p2 : Point, q1 : Point, q2 : Point) 
	-> (del_p1_theta : tensor[3](float), del_p2_theta : tensor[3](float), del_q1_theta : tensor[3](float), del_q2_theta : tensor[3](float))
  v11 = q2.x - p2.x;
  v12 = q1.x - p1.x;
  v21 = q2.x - p2.x;
  v22 = q2.x - p1.x;
  v = p2.x - p1.x;
  
  n1 = cross(v12, v);
  n2 = cross(v, v22);
  
  n1norm2 = dot(n1, n1);
  n2norm2 = dot(n2, n2);
  vnorm = norm(v);
  
  if(vnorm < 1e-8 || n1norm2 < 1e-8 || n2norm2 < 1e-8)
    del_p1_theta = {0,0,0};
    del_p2_theta = {0,0,0};
    del_q1_theta = {0,0,0};
    del_q2_theta = {0,0,0};
  else
    del_q1_theta = n1 * vnorm/n1norm2;
    del_q2_theta = n2 * vnorm/n2norm2;
    F11 = n1 * dot(v11, v) / vnorm / n1norm2;
    F12 = n2 * dot(v21, v) / vnorm / n2norm2;
    F21 = n1 * dot(-v12, v) / vnorm / n1norm2;
    F22 = n2 * dot(-v22, v) / vnorm / n2norm2;

    del_p1_theta = F11 + F12;
    del_p2_theta = F21 + F22;
  end
end

func stretchingForce(f : Face, pts : (Point*3)) -> (force : tensor[points,3](float))
  v = edgeVectors(pts);
  curSquaredNorms = {0,0,0};
  for i in 0:3
    curSquaredNorms(i) = norm(v(i));
  end

  s = curSquaredNorms - f.restLengths;
  for k in 0:3
    k2 = (k+1)%3;
    k3 = (k+2)%3;
    for l in 0:3
      for i in 0:3
        force.pts(k)(l) = -4.0 * (precomputedStretchingMatrix(i,k2) * s(i) * v(k2)(l)
				 -precomputedStretchingMatrix(i,k1) * s(i) * v(k1)(l));
      end
    end
  end    
end

func bendingForce(h : Hinge, pts : (Point*4)) -> (force : tensor[points,3](float))
  curtheta = computeAngle(pts(0), pts(1), pts(2), pts(3));
  del_p1_theta, del_p2_theta, del_q1_theta, del_q2_theta = dihedralAngleDerivatives(pts(0), pts(1), pts(2), pts(3));
  force.pts(0) = -dp1 * h.restLength / h.restPerpLength * (curtheta - h.restBendingAngle);
  force.pts(1) = -dp2 * h.restLength / h.restPerpLength * (curtheta - h.restBendingAngle);
  force.pts(2) = -dq1 * h.restLength / h.restPerpLength * (curtheta - h.restBendingAngle);
  force.pts(3) = -dq2 * h.restLength / h.restPerpLength * (curtheta - h.restBendingAngle);
end

func massMatrix(p : Point) -> (M : tensor[points, points](float))
  M(p,p) = p.m;
end

proc main
  points.x += timeStep * v;
  force = map stretchingForce to faces with points using +;
  totalforce = force * stretchingStiffness;
  force = map bendingForce to faces with points using +;
  totalforce += force * bendingStiffness;

  impulse = M \ force;
  points.v += timeStep * impulse;
end
