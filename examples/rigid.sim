const grav : Tensor[3](float) = [0.0, 0.0, -9.81];
const h : float = 0.01;

struct Rigid
	x : Tensor[4,4](float);
	v : Tensor[6](float);
	m : Tensor[4](float);
end

extern rigids Rigid{};

func compute_mass_force(r : Rigid) ->
		(M : Tensor[rigids,rigids][6,6](float), f : Tensor[rigids][6](float))
	Mr = eye(6);
	Mr(1,1) = r.m(1);
	Mr(2,2) = r.m(2);
	Mr(3,3) = r.m(3);
	Mr(4,4) = r.m(4);
	Mr(5,5) = r.m(4);
	Mr(6,6) = r.m(4);
	M(r,r) =  Mr;
	% Coriolis force
	phi = r.v;
	fc = Mr * phi;
	fc(1:3) = cross(phi(1:3), fc(1:3));
	fc(4:6) = cross(phi(1:3), fc(4:6));
	f(r) = f(r) - fc;
	% Gravity force;
	R = r.x(1:3,1:3);
	fg = zeros(6,1);
	fg(4:6) = r.m(4) * R' * grav;
	f(r) = f(r) + fg;
end

func integrate_velocity(r : Rigid) ->
		(x : Tensor[rigids][4,4](float))
	E0 = x(r);
	I = eye(3);
	w = r.v(1:3);
	v = r.v(4:6);
	wlen = norm(w);
	phib = eye(4);
	if wlen < 1e-8
		phib(1:3,4) = h*v;
	else
		w = w / wlen;
		v = v / wlen;
		wX = w(1);
		wY = w(2);
		wZ = w(3);
		c = cos(wlen * h);
		s = sin(wlen * h);
		c1 = 1 - c;
		R(1,1) = c + wX * wX * c1;
		R(1,2) = -wZ * s + wX * wY * c1;
		R(1,3) = wY * s + wX * wZ * c1;
		R(2,1) = wZ * s + wX * wY * c1;
		R(2,2) = c + wY * wY * c1;
		R(2,3) = -wX * s + wY * wZ * c1;
		R(3,1) = -wY * s + wX * wZ * c1;
		R(3,2) = wX * s + wY * wZ * c1;
		R(3,3) = c + wZ * wZ * c1;
		A = I - R;
		cc = cross(w, v);
		d = A * cc;
		wv = dot(w, v);
		p = (wv * wlen * h) * w + d;
		phib(1:3,1:3) = R;
		phib(1:3,4) = p;
	end
	E1 = E0 * phib;
	x(r) = E1;
end

proc main
	x = rigids.x;
	v = rigids.v;

	M, f = map compute_mass_force to rigids;

	p  = M*v + h*f;
	v  = M \ p;

	x = map integrate_velocity to rigids;

	rigids.x = x;
	rigids.v = v;
end

