const grav      : tensor[3](float) = [0.0, 0.0, -9.81];
const stiffness : float = 1.0e3;
const h         : float = 0.01;
const eye3      : tensor[3,3](float) = [1.0, 0.0, 0.0; 0.0, 1.0, 0.0; 0.0, 0.0, 1.0];

element Point
  x : tensor[3](float);
  v : tensor[3](float);
end

element Spring
  m  : float;
  l0 : float;
end

extern points  : set{Point};
extern springs : set{Spring}(points,points);

func distribute_masses(s : Spring, p : (Point*2)) ->
    (M : tensor[points,points](tensor[3,3](float)), f : tensor[points](tensor[3](float)))
  M(p(0), p(0)) = 0.5*s.m*eye3;
  M(p(1), p(1)) = 0.5*s.m*eye3;
  f(p(0)) = 0.5*s.m*grav;
  f(p(1)) = 0.5*s.m*grav;
end

func compute_stiffness(s : Spring, p : (Point*2)) ->
     (K : tensor[points,points](tensor[3,3](float)), f : tensor[points](tensor[3](float)))
  dx = p(1).x - p(0).x;
  l = norm(dx);
  f0 = stiffness/(s.l0*s.l0)*(l-s.l0)*dx/l;
  f1 = -f0;
  f(p(0)) = f0;
  f(p(1)) = f1;

  k = stiffness / (s.l0*s.l0*l*l)*(dx*dx' + (l-s.l0)/l*(dx'*dx*eye3 - dx*dx'));
  K(p(0), p(0)) =  k;
  K(p(0), p(1)) = -k;
  K(p(1), p(0)) = -k;
  K(p(1), p(1)) =  k;
end

proc main
  x = points.x;
  v = points.v;

  M, fg = map distribute_masses to springs with points reduce +;
  K, fs = map compute_stiffness to springs with points reduce +;
  f = fs + fg;

  p  = M*v + (h*f)';
  Mk = M + h*h*K;
  v  = Mk \ p;
  x  = x + h*v;

  points.x = x;
  points.v = v;
end
