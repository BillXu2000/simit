const grav : tensor[3](float) = [0.0, 0.0, -9.81];
const unitx : tensor[3](float) = [1.0, 0.0, 0.0];
const unity : tensor[3](float) = [0.0, 1.0, 0.0];
const unitz : tensor[3](float) = [0.0, 0.0, 1.0];
const h : float = 0.01;


element Rigid
	Q : tensor[3,3](float);
	q : tensor[3](float);
	w : tensor[3](float);
	v : tensor[3](float);
	I : tensor[3](float);
end

extern rigids : set{Rigid};

func rotationMatrix( angle : float, unitaxis : tensor[3](float)) -> (R : tensor[3,3](float))
		axis = -unitaxis;
		sin_axis  = sin(angle) * axis;
  	c = cos(angle);
		cos1_axis = (1.0 - c) * axis;
  	d = cos1_axis(1.0) * axis(2.0);
  	R(1,2) = d - sin_axis(3);
  	R(2,1) = d + sin_axis(3);

  	d = cos1_axis(1) * axis(3);
  	R(1,3) = d + sin_axis(2);
  	R(3,1) = d - sin_axis(2);

  	d = cos1_axis(2) * axis(3);
  	R(2,3) = d - sin_axis(1);
  	R(3,2) = d + sin_axis(1);
  	R(1,1) = cos1_axis(1) * axis(1);
  	R(2,2) = cos1_axis(2) * axis(2);
  	R(3,3) = cos1_axis(3) * axis(3);
end

func step_SH(r : Rigid) ->
		(Q : tensor[rigids](tensor[3,3](float)),
		q : tensor[rigids](tensor[3](float)),
		w : tensor[rigids](tensor[3](float)))
	wlocal = r.w;
	I = r.I;
	pi= I'*wlocal;
	q(r) = r.q + h*r.v;
	Q(r) = r.Q;
	R = rotationMatrix(0.5*h*pi(3)/I(3), unitz);
	Q(r) = Q(r)*R';
	pi = R*pi;
	R = rotationMatrix(0.5*h*pi(2)/I(2), unity);
	Q(r) = Q(r)*R';
	pi = R*pi;
	R = rotationMatrix(h*pi(1)/I(1), unitx);
	Q(r)  = Q(r)*R';
	pi = R*pi;
	R = rotationMatrix(0.5*h*pi(2)/I(2), unity);
	Q(r) = Q(r)*R';
	pi= R*pi;
	R = rotationMatrix(0.5*h*pi(3)/I(3), unitz);
	Q(r) = Q(r)*R';
	pi = R*pi;
	wlocal(1) = pi(1)/I(1);
	wlocal(2) = pi(2)/I(2);
	wlocal(3) = pi(3)/I(3);
	w(r) = wlocal;
end

proc main
	Q = rigids.Q;
	w = rigids.w;
	q = rigids.q;
	Q, q, w = map step_SH to rigids reduce +;
	rigids.Q = Q;
	rigids.w = w;
	rigids.q = q;
end

