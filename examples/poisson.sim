const h : float = 0.01;

element Point
	x : tensor[3](float);
	v : tensor[3](float);
	f : float;
end

element Triangle
end

extern points : Point{};
extern triangles : Triangle[points, points, points]{};

func buildMassMatrix(t : Triangle, p0 : Point, p1 : Point, p2 : Point) -> (M : tensor[points, points](float))
	e0 = p0.x - p1.x;
	e1 = p2.x - p1.x;
	area = 0.5*norm(cross(e0, e1));
	M(p0,p0) = 1.0/3.0 * area;
	M(p1,p1) = 1.0/3.0 * area;
	M(p2,p2) = 1.0/3.0 * area;
end

func buildCotanMatrix(t : Triangle, p0 : Point, p1 : Point, p2 : Point) -> (L : tensor[points,points](float))	
	e0 = p0.x - p1.x;
	e1 = p2.x - p1.x;
	sintheta = norm(cross(e0,e1));
	costheta = dot(e0, e1);
	weight = 0.5*costheta/sintheta;
	L(p0, p2) = weight;
	L(p2, p0) = weight;
	L(p0, p0) = -weight;
	L(p2, p2) = -weight;

	e0 = p1.x - p2.x;
	e1 = p0.x - p2.x;
	sintheta = norm(cross(e0,e1));
	costheta = dot(e0, e1);
	weight = 0.5*costheta/sintheta;
	L(p0, p1) = weight;
	L(p1, p0) = weight;
	L(p0, p0) = -weight;
	L(p1, p1) = -weight;

	e0 = p2.x - p0.x;
	e1 = p1.x - p0.x;
	sintheta = norm(cross(e0,e1));
	costheta = dot(e0, e1);
	weight = 0.5*costheta/sintheta;
	L(p2, p1) = weight;
	L(p1, p2) = weight;
	L(p2, p2) = -weight;
	L(p1, p1) = -weight;
end

proc main
	f = points.f;

	M = map buildMassMatrix to triangles with points reduce +;
	L = map buildCotanMatrix to triangles with points reduce +;
	
	rhs = M*f;
	Matrix = M + h*L;
	f = Matrix\f;	

	points.f = f;
end
