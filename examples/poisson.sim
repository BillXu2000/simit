const h : float = 0.01;

struct Point
	x : Tensor[3](float);
	v : Tensor[3](float);
	f : float;
end

struct Triangle
end

extern points Point{};
extern triangles Triangle[points, points, points]{};

func buildMassMatrix(t : Triangle, p0 : Point, p1 : Point, p2 : Point) -> (M : Tensor[points, points](float))
	e0 = p0 - p1;
	e1 = p2 - p1;
	area = 0.5*norm(cross(e0, e1));
	M(p0,p0) = 1.0/3.0 * area;
	M(p1,p1) = 1.0/3.0 * area;
	M(p2,p2) = 1.0/3.0 * area;
end

func buildCotanMatrix(t : Triangle, p0 : Point, p1 : Point, p2 : Point) -> (L : Tensor[points,points](float))	
	e0 = p0 - p1;
	e1 = p2 - p1;
	sintheta = norm(cross(e0,e1));
	costheta = dot(e0, e1);
	weight = 0.5*costheta/sintheta;
	L(p0, p2) = weight;
	L(p2, p0) = weight;
	L(p0, p0) = -weight;
	L(p2, p2) = -weight;

	e0 = p1 - p2;
	e1 = p0 - p2;
	sintheta = norm(cross(e0,e1));
	costheta = dot(e0, e1);
	weight = 0.5*costheta/sintheta;
	L(p0, p1) = weight;
	L(p1, p0) = weight;
	L(p0, p0) = -weight;
	L(p1, p1) = -weight;

	e0 = p2 - p0;
	e1 = p1 - p0;
	sintheta = norm(cross(e0,e1));
	costheta = dot(e0, e1);
	weight = 0.5*costheta/sintheta;
	L(p2, p1) = weight;
	L(p1, p2) = weight;
	L(p2, p2) = -weight;
	L(p1, p1) = -weight;
end

proc main
	f = points.f;

	M = map buildMassMatrix to triangles with points reduce +;
	L = map buildCotanMatrix to triangles with points reduce +;
	
	rhs = M*f;
	Matrix = M + h*L;
	f = Matrix\f;	

	points.f = f;
end
